crystal_doc_search_index_callback({"repository_name":"github.com/watzon/apatite","body":"# Apatite\n\nApatite is meant to be a collecion of mathmatical and scientific computing algorithms for the Crystal programming language. I don't expect it to ever reach the level of completeness as numpy, but hopefully it can save some people the trouble of implementing these methods on their own.\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     apatite:\n       github: watzon/apatite\n   ```\n\n2. Run `shards install`\n\n## Usage\n\n```crystal\nrequire \"apatite\"\n```\n\nCheck out the [documentation](https://watzon.github.io/apatite/) for usage examples.\n\n## Roadmap\n\n- [ ] Linear Algebra\n\t- [x] Vector\n\t- [x] Matrix\n\t- [ ] NDArray\n\t- [ ] Line\n\t- [ ] Plane\n\t- [ ] Polygon\n\t- [ ] LinkedList\n\t\n\n\n## Contributing\n\n1. Fork it (<https://github.com/watzon/apatite/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Chris Watson](https://github.com/watzon) - creator and maintainer","program":{"html_id":"github.com/watzon/apatite/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"github.com/watzon/apatite","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"github.com/watzon/apatite/Apatite","path":"Apatite.html","kind":"module","full_name":"Apatite","name":"Apatite","abstract":false,"superclass":null,"ancestors":[{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra"}],"locations":[{"filename":"apatite/linear_algebra/error.cr","line_number":1,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/error.cr"},{"filename":"apatite/linear_algebra.cr","line_number":6,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra.cr"},{"filename":"apatite.cr","line_number":10,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite.cr"},{"filename":"apatite/version.cr","line_number":1,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/version.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.1.0\"","doc":null,"summary":null}],"included_modules":[{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra"}],"extended_modules":[{"html_id":"github.com/watzon/apatite/Apatite","kind":"module","full_name":"Apatite","name":"Apatite"}],"subclasses":[],"including_types":[],"namespace":null,"doc":"Apatite is a fundimental package for scientific computing in Crystal. If that\nsounds like a modified version of the first line from the NumPy homepage,\nthat's because it is. Apatite has (ok, will have) all of the goodness\nof NumPy sitting atop the blazing speed and beautiful syntax\nof Crystal.","summary":"<p>Apatite is a fundimental package for scientific computing in Crystal.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","path":"Apatite/LinearAlgebra.html","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"apatite/linear_algebra/error.cr","line_number":2,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/error.cr"},{"filename":"apatite/linear_algebra/vector.cr","line_number":4,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr"},{"filename":"apatite/linear_algebra/matrix/eigenvalue_decomposition.cr","line_number":1,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix/eigenvalue_decomposition.cr"},{"filename":"apatite/linear_algebra/matrix/lup_decomposition.cr","line_number":1,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix/lup_decomposition.cr"},{"filename":"apatite/linear_algebra/matrix.cr","line_number":5,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr"},{"filename":"apatite/linear_algebra.cr","line_number":7,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra.cr"},{"filename":"apatite/linear_algebra/ndarray.cr","line_number":1,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra"}],"subclasses":[],"including_types":[{"html_id":"github.com/watzon/apatite/Apatite","kind":"module","full_name":"Apatite","name":"Apatite"}],"namespace":{"html_id":"github.com/watzon/apatite/Apatite","kind":"module","full_name":"Apatite","name":"Apatite"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[{"id":"sigmoid(input:Number)-instance-method","html_id":"sigmoid(input:Number)-instance-method","name":"sigmoid","doc":"Calculates the sigmoid curve for a numeric input.\n\n`f(x) = 1/(1 + e^-x)`\n\nSee also: [Sigmoid function (WikiWand)](https://www.wikiwand.com/en/Sigmoid_function)","summary":"<p>Calculates the sigmoid curve for a numeric input.</p>","abstract":false,"args":[{"name":"input","doc":null,"default_value":"","external_name":"input","restriction":"Number"}],"args_string":"(input : Number)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra.cr#L15","def":{"name":"sigmoid","args":[{"name":"input","doc":null,"default_value":"","external_name":"input","restriction":"Number"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"num = input.to_f64\n1 / (1 + (Math.exp(-num)))\n"}},{"id":"sigmoid_d(input:Number)-instance-method","html_id":"sigmoid_d(input:Number)-instance-method","name":"sigmoid_d","doc":"Calculates the derivative sigmoid curve for a numeric input.\n\n`f'(x) = f(x)(1 - f(x)),`","summary":"<p>Calculates the derivative sigmoid curve for a numeric input.</p>","abstract":false,"args":[{"name":"input","doc":null,"default_value":"","external_name":"input","restriction":"Number"}],"args_string":"(input : Number)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra.cr#L23","def":{"name":"sigmoid_d","args":[{"name":"input","doc":null,"default_value":"","external_name":"input","restriction":"Number"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"num = input.to_f64\nnum * (1 - num)\n"}}],"macros":[],"types":[{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/ErrDimensionMismatch","path":"Apatite/LinearAlgebra/ErrDimensionMismatch.html","kind":"class","full_name":"Apatite::LinearAlgebra::ErrDimensionMismatch","name":"ErrDimensionMismatch","abstract":false,"superclass":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Error","kind":"class","full_name":"Apatite::LinearAlgebra::Error","name":"Error"},"ancestors":[{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Error","kind":"class","full_name":"Apatite::LinearAlgebra::Error","name":"Error"},{"html_id":"github.com/watzon/apatite/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/apatite/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"apatite/linear_algebra/error.cr","line_number":4,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/error.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/ErrNotRegular","path":"Apatite/LinearAlgebra/ErrNotRegular.html","kind":"class","full_name":"Apatite::LinearAlgebra::ErrNotRegular","name":"ErrNotRegular","abstract":false,"superclass":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Error","kind":"class","full_name":"Apatite::LinearAlgebra::Error","name":"Error"},"ancestors":[{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Error","kind":"class","full_name":"Apatite::LinearAlgebra::Error","name":"Error"},{"html_id":"github.com/watzon/apatite/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/apatite/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"apatite/linear_algebra/error.cr","line_number":6,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/error.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/ErrOperationNotDefined","path":"Apatite/LinearAlgebra/ErrOperationNotDefined.html","kind":"class","full_name":"Apatite::LinearAlgebra::ErrOperationNotDefined","name":"ErrOperationNotDefined","abstract":false,"superclass":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Error","kind":"class","full_name":"Apatite::LinearAlgebra::Error","name":"Error"},"ancestors":[{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Error","kind":"class","full_name":"Apatite::LinearAlgebra::Error","name":"Error"},{"html_id":"github.com/watzon/apatite/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/apatite/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"apatite/linear_algebra/error.cr","line_number":8,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/error.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(method,this,other)-class-method","html_id":"new(method,this,other)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"method","doc":null,"default_value":"","external_name":"method","restriction":""},{"name":"this","doc":null,"default_value":"","external_name":"this","restriction":""},{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(method, this, other)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/error.cr#L9","def":{"name":"new","args":[{"name":"method","doc":null,"default_value":"","external_name":"method","restriction":""},{"name":"this","doc":null,"default_value":"","external_name":"this","restriction":""},{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(method, this, other)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]},{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Error","path":"Apatite/LinearAlgebra/Error.html","kind":"class","full_name":"Apatite::LinearAlgebra::Error","name":"Error","abstract":false,"superclass":{"html_id":"github.com/watzon/apatite/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"github.com/watzon/apatite/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/apatite/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"apatite/linear_algebra/error.cr","line_number":3,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/error.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/ErrDimensionMismatch","kind":"class","full_name":"Apatite::LinearAlgebra::ErrDimensionMismatch","name":"ErrDimensionMismatch"},{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/ErrNotRegular","kind":"class","full_name":"Apatite::LinearAlgebra::ErrNotRegular","name":"ErrNotRegular"},{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/ErrOperationNotDefined","kind":"class","full_name":"Apatite::LinearAlgebra::ErrOperationNotDefined","name":"ErrOperationNotDefined"},{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/ZeroVectorError","kind":"class","full_name":"Apatite::LinearAlgebra::ZeroVectorError","name":"ZeroVectorError"}],"including_types":[],"namespace":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Matrix","path":"Apatite/LinearAlgebra/Matrix.html","kind":"class","full_name":"Apatite::LinearAlgebra::Matrix(T)","name":"Matrix","abstract":false,"superclass":{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/apatite/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/apatite/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"},{"html_id":"github.com/watzon/apatite/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/apatite/Iterable","kind":"module","full_name":"Iterable","name":"Iterable"},{"html_id":"github.com/watzon/apatite/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/apatite/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"apatite/linear_algebra/matrix/eigenvalue_decomposition.cr","line_number":2,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix/eigenvalue_decomposition.cr"},{"filename":"apatite/linear_algebra/matrix/lup_decomposition.cr","line_number":2,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix/lup_decomposition.cr"},{"filename":"apatite/linear_algebra/matrix.cr","line_number":6,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"SELECTORS","name":"SELECTORS","value":"{all: true, diagonal: true, off_diagonal: true, lower: true, strict_lower: true, strict_upper: true, upper: true}","doc":null,"summary":null}],"included_modules":[{"html_id":"github.com/watzon/apatite/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/apatite/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/apatite/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra"},"doc":null,"summary":null,"class_methods":[{"id":"[](*rows)-class-method","html_id":"[](*rows)-class-method","name":"[]","doc":"Creates a matrix where each argument is a row.\n\n```\nMatrix[[25, 93], [-1, 66]]\n# => [ 25, 93,\n#      -1, 66 ]\n```","summary":"<p>Creates a matrix where each argument is a row.</p>","abstract":false,"args":[{"name":"rows","doc":null,"default_value":"","external_name":"rows","restriction":""}],"args_string":"(*rows)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L20","def":{"name":"[]","args":[{"name":"rows","doc":null,"default_value":"","external_name":"rows","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"rows(rows, false)"}},{"id":"build(row_count,column_count=row_count,&block:Int32,Int32->T)-class-method","html_id":"build(row_count,column_count=row_count,&amp;block:Int32,Int32-&gt;T)-class-method","name":"build","doc":"Creates a matrix of size +row_count+ x +column_count+.\nIt fills the values by calling the given block,\npassing the current row and column.\nReturns an enumerator if no block is given.\n\n```\nm = Matrix.build(2, 4) { |row, col| col - row }\n# => Matrix[[0, 1, 2, 3], [-1, 0, 1, 2]]\nm = Matrix.build(3) { rand }\n# => a 3x3 matrix with random elements\n```","summary":"<p>Creates a matrix of size +row_count+ x +column_count+.</p>","abstract":false,"args":[{"name":"row_count","doc":null,"default_value":"","external_name":"row_count","restriction":""},{"name":"column_count","doc":null,"default_value":"row_count","external_name":"column_count","restriction":""}],"args_string":"(row_count, column_count = row_count, &block : Int32, Int32 -> T)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L69","def":{"name":"build","args":[{"name":"row_count","doc":null,"default_value":"","external_name":"row_count","restriction":""},{"name":"column_count","doc":null,"default_value":"row_count","external_name":"column_count","restriction":""}],"double_splat":null,"splat_index":null,"yields":2,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(Int32, Int32 -> T)"},"return_type":"","visibility":"Public","body":"row_count = row_count.to_i\ncolumn_count = column_count.to_i\nif row_count < 0 || column_count < 0\n  raise(ArgumentError.new)\nend\nrows = Array(T).new(row_count) do |i|\n  Array(T).new(column_count) do |j|\n    yield i, j\n  end\nend\nnew(rows, column_count)\n"}},{"id":"column_vector(column)-class-method","html_id":"column_vector(column)-class-method","name":"column_vector","doc":"Creates a single-column matrix where the values of that column are as given\nin `column`.\n\n```\nMatrix.column_vector([4,5,6])\n# => [ 4,\n#      5,\n#      6 ]\n```","summary":"<p>Creates a single-column matrix where the values of that column are as given in <code><a href=\"../../Apatite/LinearAlgebra/Matrix.html#column%28j%29-instance-method\">#column</a></code>.</p>","abstract":false,"args":[{"name":"column","doc":null,"default_value":"","external_name":"column","restriction":""}],"args_string":"(column)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L166","def":{"name":"column_vector","args":[{"name":"column","doc":null,"default_value":"","external_name":"column","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"column = column.to_a\nnew([column].transpose, 1)\n"}},{"id":"columns(columns)-class-method","html_id":"columns(columns)-class-method","name":"columns","doc":"Creates a matrix using +columns+ as an array of column vectors.\n\n```\nMatrix.columns([[25, 93], [-1, 66]])\n# => [ 25, -1,\n#      93, 66 ]\n```","summary":"<p>Creates a matrix using +columns+ as an array of column vectors.</p>","abstract":false,"args":[{"name":"columns","doc":null,"default_value":"","external_name":"columns","restriction":""}],"args_string":"(columns)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L54","def":{"name":"columns","args":[{"name":"columns","doc":null,"default_value":"","external_name":"columns","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(rows(columns, false)).transpose"}},{"id":"combine(*matrices,&block)-class-method","html_id":"combine(*matrices,&amp;block)-class-method","name":"combine","doc":"Create a matrix by combining matrices entrywise, using the given block\n\n```\nx = Matrix[[6, 6], [4, 4]]\ny = Matrix[[1, 2], [3, 4]]\nMatrix.combine(x, y) {|a, b| a - b}\n# => Matrix[[5, 4], [1, 0]]\n```","summary":"<p>Create a matrix by combining matrices entrywise, using the given block</p>","abstract":false,"args":[{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"args_string":"(*matrices, &block)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L245","def":{"name":"combine","args":[{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"double_splat":null,"splat_index":0,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"if matrices.empty?\n  return Matrix.empty\nend\nmatrices = matrices.map do |m|\n  m = m.is_a?(Matrix) ? m : rows(m)\nend\nx = matrices.first\nmatrices.each do |m|\n  if (x.row_count == m.row_count) && (x.column_count == m.column_count)\n  else\n    raise(ErrDimensionMismatch.new)\n  end\nend\nrows = Array(T).new(x.row_count) do |i|\n  Array(T).new(x.column_count) do |j|\n    yield matrices.map do |m|\n      m[i, j]\n    end\n  end\nend\nnew(rows, x.column_count)\n"}},{"id":"diagonal(values:Indexable(T),dummy=nil)-class-method","html_id":"diagonal(values:Indexable(T),dummy=nil)-class-method","name":"diagonal","doc":"Creates a matrix where the diagonal elements are composed of `values`.\n\n```\nMatrix.diagonal(9, 5, -3)\n# =>  [ 9,  0,  0,\n#       0,  5,  0,\n#       0,  0, -3 ]\n```","summary":"<p>Creates a matrix where the diagonal elements are composed of <code>values</code>.</p>","abstract":false,"args":[{"name":"values","doc":null,"default_value":"","external_name":"values","restriction":"Indexable(T)"},{"name":"dummy","doc":null,"default_value":"nil","external_name":"dummy","restriction":""}],"args_string":"(values : Indexable(T), dummy = <span class=\"n\">nil</span>)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L89","def":{"name":"diagonal","args":[{"name":"values","doc":null,"default_value":"","external_name":"values","restriction":"Indexable(T)"},{"name":"dummy","doc":null,"default_value":"nil","external_name":"dummy","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"size = values.size\nif size == 0\n  return Matrix(T).empty\nend\nrows = Array(Array(T)).new(size) do |j|\n  row = Array(T).new(size, T.new(0))\n  row[j] = values[j]\n  row\nend\nnew(rows)\n"}},{"id":"diagonal(*values:T)-class-method","html_id":"diagonal(*values:T)-class-method","name":"diagonal","doc":"Creates a matrix where the diagonal elements are composed of `values`.\n\n```\nMatrix.diagonal(9, 5, -3)\n# =>  [ 9,  0,  0,\n#       0,  5,  0,\n#       0,  0, -3 ]\n```","summary":"<p>Creates a matrix where the diagonal elements are composed of <code>values</code>.</p>","abstract":false,"args":[{"name":"values","doc":null,"default_value":"","external_name":"values","restriction":"T"}],"args_string":"(*values : T)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L101","def":{"name":"diagonal","args":[{"name":"values","doc":null,"default_value":"","external_name":"values","restriction":"T"}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"diagonal(values, nil)"}},{"id":"empty(row_count=0,column_count=0)-class-method","html_id":"empty(row_count=0,column_count=0)-class-method","name":"empty","doc":"Creates a empty matrix of `row_count` x `column_count`.\nAt least one of `row_count` or `column_count` must be 0.\n\n```\nm = Matrix(Int32).empty(2, 0)\nm == Matrix[ [], [] ]\n# => true\nn = Matrix(Int32).empty(0, 3)\nm * n\n# => Matrix[[0, 0, 0], [0, 0, 0]]\n```","summary":"<p>Creates a empty matrix of <code><a href=\"../../Apatite/LinearAlgebra/Matrix.html#row_count-instance-method\">#row_count</a></code> x <code><a href=\"../../Apatite/LinearAlgebra/Matrix.html#column_count%3AInt32-instance-method\">#column_count</a></code>.</p>","abstract":false,"args":[{"name":"row_count","doc":null,"default_value":"0","external_name":"row_count","restriction":""},{"name":"column_count","doc":null,"default_value":"0","external_name":"column_count","restriction":""}],"args_string":"(row_count = <span class=\"n\">0</span>, column_count = <span class=\"n\">0</span>)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L182","def":{"name":"empty","args":[{"name":"row_count","doc":null,"default_value":"0","external_name":"row_count","restriction":""},{"name":"column_count","doc":null,"default_value":"0","external_name":"column_count","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (column_count != 0) && (row_count != 0)\n  raise(ArgumentError.new(\"One size must be 0\"))\nend\nif column_count < 0 || row_count < 0\n  raise(ArgumentError.new(\"Negative size\"))\nend\nnew([[] of T] * row_count, column_count)\n"}},{"id":"hstack(x,*matrices)-class-method","html_id":"hstack(x,*matrices)-class-method","name":"hstack","doc":"Create a matrix by stacking matrices horizontally\n\n```\nx = Matrix[[1, 2], [3, 4]]\ny = Matrix[[5, 6], [7, 8]]\nMatrix.hstack(x, y)\n# => Matrix[[1, 2, 5, 6], [3, 4, 7, 8]]\n```","summary":"<p>Create a matrix by stacking matrices horizontally</p>","abstract":false,"args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""},{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"args_string":"(x, *matrices)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L217","def":{"name":"hstack","args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""},{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"double_splat":null,"splat_index":1,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"result = x.rows\ntotal_column_count = x.column_count\nmatrices.each do |m|\n  m = m.is_a?(Matrix) ? m : rows(m)\n  if m.row_count != x.row_count\n    raise(ErrDimensionMismatch.new(\"The given matrices must have #{x.row_count} rows, but one has #{m.row_count}\"))\n  end\n  result.each_with_index do |row, i|\n    row.concat(m.rows[i])\n  end\n  total_column_count = total_column_count + m.column_count\nend\nnew(result, total_column_count)\n"}},{"id":"identity(n)-class-method","html_id":"identity(n)-class-method","name":"identity","doc":"Creates an `n` by `n` identity matrix.\n\n```\nMatrix.identity(2)\n# => [ 1, 0,\n#      0, 1 ]\n```","summary":"<p>Creates an <code>n</code> by <code>n</code> identity matrix.</p>","abstract":false,"args":[{"name":"n","doc":null,"default_value":"","external_name":"n","restriction":""}],"args_string":"(n)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L124","def":{"name":"identity","args":[{"name":"n","doc":null,"default_value":"","external_name":"n","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"scalar(n, T.new(1))"}},{"id":"row_vector(row)-class-method","html_id":"row_vector(row)-class-method","name":"row_vector","doc":"Creates a single-row matrix where the values of that row are as given in\n`row`.\n\n```\nMatrix.row_vector([4,5,6])\n# => [ 4, 5, 6 ]\n```","summary":"<p>Creates a single-row matrix where the values of that row are as given in <code><a href=\"../../Apatite/LinearAlgebra/Matrix.html#row%28i%2C%26block%3AVector-%3E%29-instance-method\">#row</a></code>.</p>","abstract":false,"args":[{"name":"row","doc":null,"default_value":"","external_name":"row","restriction":""}],"args_string":"(row)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L152","def":{"name":"row_vector","args":[{"name":"row","doc":null,"default_value":"","external_name":"row","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"row = row.to_a\nnew([row])\n"}},{"id":"rows(rows:Indexable(Array(T)),copy=true)-class-method","html_id":"rows(rows:Indexable(Array(T)),copy=true)-class-method","name":"rows","doc":"Creates a matrix where +rows+ is an array of arrays, each of which is a row\nof the matrix.  If the optional argument +copy+ is false, use the given\narrays as the internal structure of the matrix without copying.\n\n```\nMatrix.rows([[25, 93], [-1, 66]])\n# => [ 25, 93,\n#      -1, 66 ]\n```","summary":"<p>Creates a matrix where +rows+ is an array of arrays, each of which is a row of the matrix.</p>","abstract":false,"args":[{"name":"rows","doc":null,"default_value":"","external_name":"rows","restriction":"Indexable(Array(T))"},{"name":"copy","doc":null,"default_value":"true","external_name":"copy","restriction":""}],"args_string":"(rows : Indexable(Array(T)), copy = <span class=\"n\">true</span>)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L33","def":{"name":"rows","args":[{"name":"rows","doc":null,"default_value":"","external_name":"rows","restriction":"Indexable(Array(T))"},{"name":"copy","doc":null,"default_value":"true","external_name":"copy","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if copy\n  rows = rows.dup\nend\nrows = rows.to_a\nrows.map! do |row|\n  if row\n    row = row.dup\n  end\n  row.to_a\nend\nsize = (rows[0] || ([] of T)).size\nrows.each_with_index do |row, i|\n  if row.size == size\n  else\n    raise(ErrDimensionMismatch.new(\"row size differs (row at index `#{i}` should contain #{size} elements, instead has #{row.size})\"))\n  end\nend\nnew(rows, size)\n"}},{"id":"scalar(n,value:T)-class-method","html_id":"scalar(n,value:T)-class-method","name":"scalar","doc":"Creates an +n+ by +n+ diagonal matrix where each diagonal element is\n`value`.\n\n```\nMatrix.scalar(2, 5)\n# => [ 5, 0,\n#      0, 5 ]\n```","summary":"<p>Creates an +n+ by +n+ diagonal matrix where each diagonal element is <code>value</code>.</p>","abstract":false,"args":[{"name":"n","doc":null,"default_value":"","external_name":"n","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"T"}],"args_string":"(n, value : T)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L113","def":{"name":"scalar","args":[{"name":"n","doc":null,"default_value":"","external_name":"n","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"T"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"diagonal(Array(T).new(n, value))"}},{"id":"unit(n:T)-class-method","html_id":"unit(n:T)-class-method","name":"unit","doc":"Creates an `n` by `n` identity matrix.\n\n```\nMatrix.identity(2)\n# => [ 1, 0,\n#      0, 1 ]\n```","summary":"<p>Creates an <code>n</code> by <code>n</code> identity matrix.</p>","abstract":false,"args":[{"name":"n","doc":null,"default_value":"","external_name":"n","restriction":"T"}],"args_string":"(n : T)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L129","def":{"name":"unit","args":[{"name":"n","doc":null,"default_value":"","external_name":"n","restriction":"T"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"identity(n)"}},{"id":"vstack(x,*matrices)-class-method","html_id":"vstack(x,*matrices)-class-method","name":"vstack","doc":"Create a matrix by stacking matrices vertically\n\n```\nx = Matrix[[1, 2], [3, 4]]\ny = Matrix[[5, 6], [7, 8]]\nMatrix.vstack(x, y)\n# => Matrix[[1, 2], [3, 4], [5, 6], [7, 8]]\n```","summary":"<p>Create a matrix by stacking matrices vertically</p>","abstract":false,"args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""},{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"args_string":"(x, *matrices)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L197","def":{"name":"vstack","args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""},{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"double_splat":null,"splat_index":1,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"result = x.rows\nmatrices.each do |m|\n  m = m.is_a?(Matrix) ? m : rows(m)\n  if m.column_count != x.column_count\n    raise(ErrDimensionMismatch.new(\"The given matrices must have #{x.column_count} columns, but one has #{m.column_count}\"))\n  end\n  result.concat(m.rows)\nend\nnew(result, x.column_count)\n"}},{"id":"zero(row_count,column_count=row_count)-class-method","html_id":"zero(row_count,column_count=row_count)-class-method","name":"zero","doc":"Creates a zero matrix.\n\n```\nMatrix.zero(2)\n# => [ 0, 0,\n#      0, 0 ]\n```","summary":"<p>Creates a zero matrix.</p>","abstract":false,"args":[{"name":"row_count","doc":null,"default_value":"","external_name":"row_count","restriction":""},{"name":"column_count","doc":null,"default_value":"row_count","external_name":"column_count","restriction":""}],"args_string":"(row_count, column_count = row_count)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L140","def":{"name":"zero","args":[{"name":"row_count","doc":null,"default_value":"","external_name":"row_count","restriction":""},{"name":"column_count","doc":null,"default_value":"row_count","external_name":"column_count","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"rows = Array(T).new(row_count) do\n  Array(T).new(column_count, T.new(0))\nend\nnew(rows, column_count)\n"}}],"constructors":[],"instance_methods":[{"id":"*(other)-instance-method","html_id":"*(other)-instance-method","name":"*","doc":"Matrix multiplication\n\n```\nMatrix[[2,4], [6,8]] * Matrix.identity(2)\n# => [ 2, 4,\n#      6, 8 ]\n```","summary":"<p>Matrix multiplication</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L891","def":{"name":"*","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case other\nwhen Number\n  rows = @rows.map do |row|\n    row.map do |e|\n      (e * other).as(T)\n    end\n  end\n  Matrix.new(rows, column_count)\nwhen Vector\n  m = Matrix.column_vector(other)\n  r = self * m\n  r.column(0)\nwhen Matrix\n  if column_count != other.column_count\n    raise(ErrDimensionMismatch.new)\n  end\n  rows = Array.new(row_count) do |i|\n    Array.new(column_count) do |j|\n      (0...column_count).reduce(0) do |vij, k|\n        vij + (self[i, k] * other[k, j])\n      end\n    end\n  end\n  Matrix.new(rows, column_count)\nelse\n  self * (Matrix.rows(other))\nend"}},{"id":"**(other)-instance-method","html_id":"**(other)-instance-method","name":"**","doc":"Matrix exponentiation.\n\nEquivalent to multiplying the matrix by itself N times.\nNon integer exponents will be handled by diagonalizing the matrix.\n\n```\nMatrix[[7,6], [3,9]] ** 2\n# => [ 67, 96,\n#      48, 99 ]\n```","summary":"<p>Matrix exponentiation.</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1061","def":{"name":"**","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":""}},{"id":"+(other:Matrix|Indexable)-instance-method","html_id":"+(other:Matrix|Indexable)-instance-method","name":"+","doc":"Matrix addition\n\n```\nMatrix.scalar(2,5) + Matrix[[1,0], [-4,7]]\n# => [ 6,  0,\n#     -4,  1 ]\n```","summary":"<p>Matrix addition</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":"Matrix | Indexable"}],"args_string":"(other : Matrix | Indexable)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L924","def":{"name":"+","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":"Matrix | Indexable"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case other\nwhen Vector\n  other = Matrix.column_vector(other)\nwhen Matrix\nelse\n  other = Matrix.rows(other)\nend\nif (row_count == other.row_count) && (column_count == other.column_count)\nelse\n  raise(ErrDimensionMismatch.new)\nend\nrows = Array.new(row_count) do |i|\n  Array.new(column_count) do |j|\n    (self[i, j] + other[i, j]).as(T)\n  end\nend\nMatrix.new(rows, column_count)\n"}},{"id":"-(other:Matrix|Indexable)-instance-method","html_id":"-(other:Matrix|Indexable)-instance-method","name":"-","doc":"Matrix subtraction\n\n```\nMatrix[[1,5], [4,2]] - Matrix[[9,3], [-4,1]]\n# => [-8, 2,\n#      8, 1 ]\n```","summary":"<p>Matrix subtraction</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":"Matrix | Indexable"}],"args_string":"(other : Matrix | Indexable)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L951","def":{"name":"-","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":"Matrix | Indexable"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case other\nwhen Vector\n  other = Matrix.column_vector(other)\nwhen Matrix\nelse\n  other = Matrix.rows(other)\nend\nif (row_count == other.row_count) && (column_count == other.column_count)\nelse\n  raise(ErrDimensionMismatch.new)\nend\nrows = Array.new(row_count) do |i|\n  Array.new(column_count) do |j|\n    (self[i, j] - other[i, j]).as(T)\n  end\nend\nMatrix.new(rows, column_count)\n"}},{"id":"/(other)-instance-method","html_id":"/(other)-instance-method","name":"/","doc":"Matrix division (multiplication by the inverse).\n\n```\nMatrix[[7,6], [3,9]] / Matrix[[2,9], [3,1]]\n# => [ -7,  1,\n#      -3, -6 ]\n```","summary":"<p>Matrix division (multiplication by the inverse).</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L978","def":{"name":"/","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case other\nwhen Number\n  rows = @rows.map do |row|\n    row.map do |e|\n      (e / other).as(T)\n    end\n  end\n  return Matrix.new(rows, column_count)\nwhen Matrix\n  return self * other.inverse\nelse\n  self / (Matrix.rows(other))\nend"}},{"id":"==(other:Matrix)-instance-method","html_id":"==(other:Matrix)-instance-method","name":"==","doc":"Equality operator","summary":"<p>Equality operator</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":"Matrix"}],"args_string":"(other : Matrix)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L868","def":{"name":"==","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":"Matrix"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(rows == other.rows) && (column_count == other.column_count)"}},{"id":"[](i)-instance-method","html_id":"[](i)-instance-method","name":"[]","doc":"Returns row `i` of the matrix as an Array. Raises if the\nindex is not found.","summary":"<p>Returns row <code>i</code> of the matrix as an Array.</p>","abstract":false,"args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"args_string":"(i)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L279","def":{"name":"[]","args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@rows[i]"}},{"id":"[](i,j)-instance-method","html_id":"[](i,j)-instance-method","name":"[]","doc":"Returns element (`i`, `j`) of the matrix.  That is: row `i`, column `j`.\nRaises if either index is not found.","summary":"<p>Returns element (<code>i</code>, <code>j</code>) of the matrix.</p>","abstract":false,"args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""},{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""}],"args_string":"(i, j)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L291","def":{"name":"[]","args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""},{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@rows[i][j]"}},{"id":"[]=(i,j,v:T)-instance-method","html_id":"[]=(i,j,v:T)-instance-method","name":"[]=","doc":"Set the value at index (`i`, `j`). That is: row `i`, column `j`.","summary":"<p>Set the value at index (<code>i</code>, <code>j</code>).</p>","abstract":false,"args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""},{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""},{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":"T"}],"args_string":"(i, j, v : T)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L302","def":{"name":"[]=","args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""},{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""},{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":"T"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@rows[i][j] = v"}},{"id":"[]?(i)-instance-method","html_id":"[]?(i)-instance-method","name":"[]?","doc":"Returns row `i` of the matrix as an Array. Returns nil if the\nindex is not found.","summary":"<p>Returns row <code>i</code> of the matrix as an Array.</p>","abstract":false,"args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"args_string":"(i)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L285","def":{"name":"[]?","args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@rows[i]?"}},{"id":"[]?(i,j)-instance-method","html_id":"[]?(i,j)-instance-method","name":"[]?","doc":"Returns element (`i`, `j`) of the matrix.  That is: row `i`, column `j`.\nReturns nil if either index is not found.","summary":"<p>Returns element (<code>i</code>, <code>j</code>) of the matrix.</p>","abstract":false,"args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""},{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""}],"args_string":"(i, j)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L297","def":{"name":"[]?","args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""},{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@rows[i]?.try(&.[]?(j))"}},{"id":"adjugate-instance-method","html_id":"adjugate-instance-method","name":"adjugate","doc":"Returns the adjugate of the matrix.\n\nMatrix[ [7,6],[3,9] ].adjugate\n# => [ 9, -6,\n#     -3,  7 ]\n```","summary":"<p>Returns the adjugate of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L626","def":{"name":"adjugate","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if square?\nelse\n  raise(ErrDimensionMismatch.new)\nend\nMatrix.build(row_count, column_count) do |row, column|\n  cofactor(column, row)\nend\n"}},{"id":"clone-instance-method","html_id":"clone-instance-method","name":"clone","doc":"Returns a clone of the matrix, so that the contents of each do not reference\nidentical objects.\n\nThere should be no good reason to do this since Matrices are immutable.","summary":"<p>Returns a clone of the matrix, so that the contents of each do not reference identical objects.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L876","def":{"name":"clone","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"Matrix.new(@rows.map(&.dup), column_count)"}},{"id":"coerce(klass)-instance-method","html_id":"coerce(klass)-instance-method","name":"coerce","doc":"Attempt to coerce the elements in the matrix to another type.","summary":"<p>Attempt to coerce the elements in the matrix to another type.</p>","abstract":false,"args":[{"name":"klass","doc":null,"default_value":"","external_name":"klass","restriction":""}],"args_string":"(klass)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1365","def":{"name":"coerce","args":[{"name":"klass","doc":null,"default_value":"","external_name":"klass","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"rws = @rows.map do |r|\n  r.map do |i|\n    klass.new(i)\n  end\nend\nMatrix.rows(rws)\n"}},{"id":"cofactor(row,column)-instance-method","html_id":"cofactor(row,column)-instance-method","name":"cofactor","doc":"Returns the (row, column) cofactor which is obtained by multiplying\nthe first minor by (-1)**(row + column).\n\n```\nMatrix.diagonal(9, 5, -3, 4).cofactor(1, 1)\n# => -108\n```","summary":"<p>Returns the (row, column) cofactor which is obtained by multiplying the first minor by (-1)**(row + column).</p>","abstract":false,"args":[{"name":"row","doc":null,"default_value":"","external_name":"row","restriction":""},{"name":"column","doc":null,"default_value":"","external_name":"column","restriction":""}],"args_string":"(row, column)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L612","def":{"name":"cofactor","args":[{"name":"row","doc":null,"default_value":"","external_name":"row","restriction":""},{"name":"column","doc":null,"default_value":"","external_name":"column","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if empty?\n  raise(\"cofactor of empty matrix is not defined\")\nend\nif square?\nelse\n  raise(ErrDimensionMismatch.new)\nend\ndet_of_minor = (first_minor(row, column)).determinant\ndet_of_minor * ((-1) ** (row + column))\n"}},{"id":"column(j)-instance-method","html_id":"column(j)-instance-method","name":"column","doc":"Returns column vector `j` of the Matrix as a Vector (starting at 0).\nRaises if the column doesn't exist.","summary":"<p>Returns column vector <code>j</code> of the Matrix as a Vector (starting at 0).</p>","abstract":false,"args":[{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""}],"args_string":"(j)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L336","def":{"name":"column","args":[{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if j >= column_count || j < (-column_count)\n  raise(IndexError.new)\nend\ncol = Array(T).new(row_count) do |i|\n  @rows[i][j]\nend\nVector.elements(col, false)\n"}},{"id":"column(j,&block:T->)-instance-method","html_id":"column(j,&amp;block:T-&gt;)-instance-method","name":"column","doc":"Returns a block which yields every item in column `j` of the Matrix.","summary":"<p>Returns a block which yields every item in column <code>j</code> of the Matrix.</p>","abstract":false,"args":[{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""}],"args_string":"(j, &block : T -> )","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L353","def":{"name":"column","args":[{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T -> )"},"return_type":"","visibility":"Public","body":"(column(j)).each(&block)"}},{"id":"column?(j)-instance-method","html_id":"column?(j)-instance-method","name":"column?","doc":"Returns column vector `j` of the Matrix as a Vector (starting at 0).\nReturns nil if the column doesn't exist.","summary":"<p>Returns column vector <code>j</code> of the Matrix as a Vector (starting at 0).</p>","abstract":false,"args":[{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""}],"args_string":"(j)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L346","def":{"name":"column?","args":[{"name":"j","doc":null,"default_value":"","external_name":"j","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"begin\n  column(j)\nrescue IndexError\n  nil\nend"}},{"id":"column_count:Int32-instance-method","html_id":"column_count:Int32-instance-method","name":"column_count","doc":"Returns the number of columns.","summary":"<p>Returns the number of columns.</p>","abstract":false,"args":[],"args_string":" : Int32","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L314","def":{"name":"column_count","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int32","visibility":"Public","body":"@column_count"}},{"id":"column_vectors-instance-method","html_id":"column_vectors-instance-method","name":"column_vectors","doc":"Returns an array of the column vectors of the matrix. See `Vector`.","summary":"<p>Returns an array of the column vectors of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1378","def":{"name":"column_vectors","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"Array.new(column_count) do |i|\n  column(i)\nend"}},{"id":"combine(*matrices,&block)-instance-method","html_id":"combine(*matrices,&amp;block)-instance-method","name":"combine","doc":"Create a matrix by combining matrices entrywise, using the given block\n\n```\nx = Matrix[[6, 6], [4, 4]]\ny = Matrix[[1, 2], [3, 4]]\nMatrix.combine(x, y) {|a, b| a - b}\n# => Matrix[[5, 4], [1, 0]]\n```","summary":"<p>Create a matrix by combining matrices entrywise, using the given block</p>","abstract":false,"args":[{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"args_string":"(*matrices, &block)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L264","def":{"name":"combine","args":[{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"double_splat":null,"splat_index":0,"yields":0,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":""},"return_type":"","visibility":"Public","body":"Matrix.combine(self, *matrices, &block)"}},{"id":"conj-instance-method","html_id":"conj-instance-method","name":"conj","doc":"Returns the conjugate of the matrix.\n\n```\nMatrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n# => 1+2i   i  0\n#       1   2  3\nMatrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].conj\n# => 1-2i  -i  0\n#       1   2  3\n```","summary":"<p>Returns the conjugate of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1313","def":{"name":"conj","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if real?\nelse\n  raise(ArgumentError.new(\"Matrix#conj only works with real matrices (i.e. Matrix(Complex))\"))\nend\nmap(&.conj)\n"}},{"id":"determinant-instance-method","html_id":"determinant-instance-method","name":"determinant","doc":"Returns the determinant of the matrix.\n\nBeware that using Float values can yield erroneous results\nbecause of their lack of precision.\nConsider using exact types like Rational or BigDecimal instead.\n\n```\nMatrix[[7,6], [3,9]].determinant\n# => 45\n```","summary":"<p>Returns the determinant of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1079","def":{"name":"determinant","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if square?\nelse\n  raise(ErrDimensionMismatch.new)\nend\nm = rows\ncase row_count\nwhen 0\n  +1\nwhen 1\n  +m[0][0]\nwhen 2\n  ((+m[0][0]) * m[1][1]) - (m[0][1] * m[1][0])\nwhen 3\n  m0, m1, m2 = m\n  (((((((+m0[0]) * m1[1]) * m2[2]) - ((m0[0] * m1[2]) * m2[1])) - ((m0[1] * m1[0]) * m2[2])) + ((m0[1] * m1[2]) * m2[0])) + ((m0[2] * m1[0]) * m2[1])) - ((m0[2] * m1[1]) * m2[0])\nwhen 4\n  m0, m1, m2, m3 = m\n  ((((((((((((((((((((((((((+m0[0]) * m1[1]) * m2[2]) * m3[3]) - (((m0[0] * m1[1]) * m2[3]) * m3[2])) - (((m0[0] * m1[2]) * m2[1]) * m3[3])) + (((m0[0] * m1[2]) * m2[3]) * m3[1])) + (((m0[0] * m1[3]) * m2[1]) * m3[2])) - (((m0[0] * m1[3]) * m2[2]) * m3[1])) - (((m0[1] * m1[0]) * m2[2]) * m3[3])) + (((m0[1] * m1[0]) * m2[3]) * m3[2])) + (((m0[1] * m1[2]) * m2[0]) * m3[3])) - (((m0[1] * m1[2]) * m2[3]) * m3[0])) - (((m0[1] * m1[3]) * m2[0]) * m3[2])) + (((m0[1] * m1[3]) * m2[2]) * m3[0])) + (((m0[2] * m1[0]) * m2[1]) * m3[3])) - (((m0[2] * m1[0]) * m2[3]) * m3[1])) - (((m0[2] * m1[1]) * m2[0]) * m3[3])) + (((m0[2] * m1[1]) * m2[3]) * m3[0])) + (((m0[2] * m1[3]) * m2[0]) * m3[1])) - (((m0[2] * m1[3]) * m2[1]) * m3[0])) - (((m0[3] * m1[0]) * m2[1]) * m3[2])) + (((m0[3] * m1[0]) * m2[2]) * m3[1])) + (((m0[3] * m1[1]) * m2[0]) * m3[2])) - (((m0[3] * m1[1]) * m2[2]) * m3[0])) - (((m0[3] * m1[2]) * m2[0]) * m3[1])) + (((m0[3] * m1[2]) * m2[1]) * m3[0])\nelse\n  determinant_bareiss\nend\n"}},{"id":"diagonal?-instance-method","html_id":"diagonal?-instance-method","name":"diagonal?","doc":"Returns `true` if this is a diagonal matrix.\n","summary":"<p>Returns <code>true</code> if this is a diagonal matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L697","def":{"name":"diagonal?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if square?\nelse\n  return false\nend\nels = [] of T\neach(:off_diagonal) do |e|\n  els << e\nend\nels.all?(&.zero?)\n"}},{"id":"each(which=:all,&block:T->)-instance-method","html_id":"each(which=:all,&amp;block:T-&gt;)-instance-method","name":"each","doc":"Yields all elements of the matrix, starting with those of the first row,\nor returns an Enumerator if no block given.\nElements can be restricted by passing an argument:\n* :all (default): yields all elements\n* :diagonal: yields only elements on the diagonal\n* :off_diagonal: yields all elements except on the diagonal\n* :lower: yields only elements on or below the diagonal\n* :strict_lower: yields only elements below the diagonal\n* :strict_upper: yields only elements above the diagonal\n* :upper: yields only elements on or above the diagonal\n\n```\nMatrix[ [1,2], [3,4] ].each { |e| puts e }\n# => prints the numbers 1 to 4\nMatrix[ [1,2], [3,4] ].each(:strict_lower).to_a # => [3]\n```","summary":"<p>Yields all elements of the matrix, starting with those of the first row, or returns an Enumerator if no block given.</p>","abstract":false,"args":[{"name":"which","doc":null,"default_value":":all","external_name":"which","restriction":""}],"args_string":"(which = <span class=\"n\">:all</span>, &block : T -> )","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L380","def":{"name":"each","args":[{"name":"which","doc":null,"default_value":":all","external_name":"which","restriction":""}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T -> )"},"return_type":"","visibility":"Public","body":"last = column_count\ncase which.to_s\nwhen \"all\"\n  @rows.each do |row|\n    row.each(&block)\n  end\nwhen \"diagonal\"\n  @rows.each_with_index do |row, row_index|\n    yield row.fetch(row_index) do\n      return self\n    end\n  end\nwhen \"off_diagonal\"\n  @rows.each_with_index do |row, row_index|\n    column_count.times do |col_index|\n      if row_index == col_index\n      else\n        yield row[col_index]\n      end\n    end\n  end\nwhen \"lower\"\n  @rows.each_with_index do |row, row_index|\n    0.upto([row_index, last].min) do |col_index|\n      yield row[col_index]\n    end\n  end\nwhen \"strict_lower\"\n  @rows.each_with_index do |row, row_index|\n    [row_index, column_count].min.times do |col_index|\n      yield row[col_index]\n    end\n  end\nwhen \"strict_upper\"\n  @rows.each_with_index do |row, row_index|\n    (row_index + 1).upto(last - 1) do |col_index|\n      yield row[col_index]\n    end\n  end\nwhen \"upper\"\n  @rows.each_with_index do |row, row_index|\n    row_index.upto(last - 1) do |col_index|\n      yield row[col_index]\n    end\n  end\nelse\n  raise(ArgumentError.new(\"expected #{which.inspect} to be one of :all, :diagonal, :off_diagonal, :lower, :strict_lower, :strict_upper or :upper\"))\nend\n"}},{"id":"each_with_index(which=:all,&block:T,Int32,Int32->)-instance-method","html_id":"each_with_index(which=:all,&amp;block:T,Int32,Int32-&gt;)-instance-method","name":"each_with_index","doc":"Same as #each, but the row index and column index in addition to the element\n\n```\nMatrix[ [1,2], [3,4] ].each_with_index do |e, row, col|\nputs \"#{e} at #{row}, #{col}\"\nend\n# => Prints:\n#    1 at 0, 0\n#    2 at 0, 1\n#    3 at 1, 0\n#    4 at 1, 1\n```","summary":"<p>Same as #each, but the row index and column index in addition to the element</p>","abstract":false,"args":[{"name":"which","doc":null,"default_value":":all","external_name":"which","restriction":""}],"args_string":"(which = <span class=\"n\">:all</span>, &block : T, Int32, Int32 -> )","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L438","def":{"name":"each_with_index","args":[{"name":"which","doc":null,"default_value":":all","external_name":"which","restriction":""}],"double_splat":null,"splat_index":null,"yields":3,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T, Int32, Int32 -> )"},"return_type":"","visibility":"Public","body":"last = column_count\ncase which.to_s\nwhen \"all\"\n  @rows.each_with_index do |row, row_index|\n    row.each_with_index do |e, col_index|\n      block.call(e, row_index, col_index)\n    end\n  end\nwhen \"diagonal\"\n  @rows.each_with_index do |row, row_index|\n    block.call(row.fetch(row_index) do\n      return self\n    end, row_index, row_index)\n  end\nwhen \"off_diagonal\"\n  @rows.each_with_index do |row, row_index|\n    column_count.times do |col_index|\n      block.call(row[col_index], row_index, col_index)\n    end\n  end\nwhen \"lower\"\n  @rows.each_with_index do |row, row_index|\n    0.upto([row_index, last].min) do |col_index|\n      block.call(row[col_index], row_index, col_index)\n    end\n  end\nwhen \"strict_lower\"\n  @rows.each_with_index do |row, row_index|\n    [row_index, column_count].min.times do |col_index|\n      block.call(row[col_index], row_index, col_index)\n    end\n  end\nwhen \"strict_upper\"\n  @rows.each_with_index do |row, row_index|\n    (row_index + 1).upto(last - 1) do |col_index|\n      block.call(row[col_index], row_index, col_index)\n    end\n  end\nwhen \"upper\"\n  @rows.each_with_index do |row, row_index|\n    row_index.upto(last - 1) do |col_index|\n      block.call(row[col_index], row_index, col_index)\n    end\n  end\nelse\n  raise(ArgumentError.new(\"expected #{which.inspect} to be one of :all, :diagonal, :off_diagonal, :lower, :strict_lower, :strict_upper or :upper\"))\nend\n"}},{"id":"eigensystem-instance-method","html_id":"eigensystem-instance-method","name":"eigensystem","doc":"Returns the Eigensystem of the matrix\nSee `EigenvalueDecomposition`.\n\nNOTE: Not working yet\n\n```\nm = Matrix[[1, 2], [3, 4]]\nv, d, v_inv = m.eigensystem\nd.diagonal? # => true\nv.inv == v_inv # => true\n(v * d * v_inv).round(5) == m # => true\n```","summary":"<p>Returns the Eigensystem of the matrix See <code><a href=\"../../Apatite/LinearAlgebra/Matrix/EigenvalueDecomposition.html\">EigenvalueDecomposition</a></code>.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1277","def":{"name":"eigensystem","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"EigenvalueDecomposition.new(self)"}},{"id":"empty?-instance-method","html_id":"empty?-instance-method","name":"empty?","doc":"Returns true if this matrix is empty.","summary":"<p>Returns true if this matrix is empty.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L705","def":{"name":"empty?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(column_count == 0) || (row_count == 0)"}},{"id":"first_minor(row,column)-instance-method","html_id":"first_minor(row,column)-instance-method","name":"first_minor","doc":"Returns the submatrix obtained by deleting the specified row and column.\n\n```\nMatrix.diagonal(9, 5, -3, 4).first_minor(1, 2)\n# => [ 9, 0, 0,\n#      0, 0, 0,\n#      0, 0, 4 ]\n```","summary":"<p>Returns the submatrix obtained by deleting the specified row and column.</p>","abstract":false,"args":[{"name":"row","doc":null,"default_value":"","external_name":"row","restriction":""},{"name":"column","doc":null,"default_value":"","external_name":"column","restriction":""}],"args_string":"(row, column)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L585","def":{"name":"first_minor","args":[{"name":"row","doc":null,"default_value":"","external_name":"row","restriction":""},{"name":"column","doc":null,"default_value":"","external_name":"column","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if empty?\n  raise(\"first_minor of empty matrix is not defined\")\nend\nif 0 <= row && row < row_count\nelse\n  raise(ArgumentError.new(\"invalid row (#{row.inspect} for 0..#{row_count - 1})\"))\nend\nif 0 <= column && column < column_count\nelse\n  raise(ArgumentError.new(\"invalid column (#{column.inspect} for 0..#{column_count - 1})\"))\nend\narrays = to_a\narrays.delete_at(row)\narrays.each do |array|\n  array.delete_at(column)\nend\nMatrix.new(arrays, column_count - 1)\n"}},{"id":"hadamard_product(m)-instance-method","html_id":"hadamard_product(m)-instance-method","name":"hadamard_product","doc":"Hadamard product\n\n```\nMatrix[[1,2], [3,4]].hadamard_product Matrix[[1,2], [3,2]]\n# => [ 1,  4,\n#      9,  8 ]\n```","summary":"<p>Hadamard product</p>","abstract":false,"args":[{"name":"m","doc":null,"default_value":"","external_name":"m","restriction":""}],"args_string":"(m)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L999","def":{"name":"hadamard_product","args":[{"name":"m","doc":null,"default_value":"","external_name":"m","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"combine(m) do |a, b|\n  a * b\nend"}},{"id":"hermitian?-instance-method","html_id":"hermitian?-instance-method","name":"hermitian?","doc":"Returns `true` if this is an hermitian matrix.","summary":"<p>Returns <code>true</code> if this is an hermitian matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L710","def":{"name":"hermitian?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if square?\nelse\n  return false\nend\nels = [] of Tuple(T, Int32, Int32)\neach_with_index(:upper) do |e, i, j|\n  els << {e, i, j}\nend\nels.all? do |e, row, col|\n  e == rows[col][row]\nend\n"}},{"id":"hstack(*matrices)-instance-method","html_id":"hstack(*matrices)-instance-method","name":"hstack","doc":"Returns a new matrix resulting by stacking horizontally\nthe receiver with the given matrices\n\n```\nx = Matrix[[1, 2], [3, 4]]\ny = Matrix[[5, 6], [7, 8]]\nx.hstack(y) # => Matrix[[1, 2, 5, 6], [3, 4, 7, 8]]\n```","summary":"<p>Returns a new matrix resulting by stacking horizontally the receiver with the given matrices</p>","abstract":false,"args":[{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"args_string":"(*matrices)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1161","def":{"name":"hstack","args":[{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.hstack(self, *matrices)"}},{"id":"imag-instance-method","html_id":"imag-instance-method","name":"imag","doc":"Returns the imaginary part of the matrix.\n\n```\nMatrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n# => [ 1+2i,  i,  0,\n#         1,  2,  3 ]\nMatrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].imag\n# => [ 2i,  i,  0,\n#       0,  0,  0 ]\n```","summary":"<p>Returns the imaginary part of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1328","def":{"name":"imag","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if real?\nelse\n  raise(ArgumentError.new(\"Matrix#imag only works with real matrices (i.e. Matrix(Complex))\"))\nend\nmap(&.imag)\n"}},{"id":"index(i,selector=:all)-instance-method","html_id":"index(i,selector=:all)-instance-method","name":"index","doc":"The index method is specialized to return the index as {row, column}\nIt also accepts an optional `selector` argument, see `#each` for details.\n\n```\nMatrix[ [1,1], [1,1] ].index(1, :strict_lower)\n# => {1, 0}\n```","summary":"<p>The index method is specialized to return the index as {row, column} It also accepts an optional <code>selector</code> argument, see <code><a href=\"../../Apatite/LinearAlgebra/Matrix.html#each%28which%3D%3Aall%2C%26block%3AT-%3E%29-instance-method\">#each</a></code> for details.</p>","abstract":false,"args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""},{"name":"selector","doc":null,"default_value":":all","external_name":"selector","restriction":""}],"args_string":"(i, selector = <span class=\"n\">:all</span>)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L495","def":{"name":"index","args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""},{"name":"selector","doc":null,"default_value":":all","external_name":"selector","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"res = nil\neach_with_index(selector) do |e, row_index, col_index|\n  if e == i\n    res = {row_index, col_index}\n    next\n  end\nend\nres\n"}},{"id":"index(selector=:all,&block:T->Bool)-instance-method","html_id":"index(selector=:all,&amp;block:T-&gt;Bool)-instance-method","name":"index","doc":"Returns the index as {row, column}, using `&block` to filter the\nresult. It also accepts an optional `selector` argument, see\n`#each` for details.\n\n```\nMatrix[ [1,2], [3,4] ].index(&.even?)\n# => {0, 1}\n```","summary":"<p>Returns the index as {row, column}, using <code>&block</code> to filter the result.</p>","abstract":false,"args":[{"name":"selector","doc":null,"default_value":":all","external_name":"selector","restriction":""}],"args_string":"(selector = <span class=\"n\">:all</span>, &block : T -> Bool)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L514","def":{"name":"index","args":[{"name":"selector","doc":null,"default_value":":all","external_name":"selector","restriction":""}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T -> Bool)"},"return_type":"","visibility":"Public","body":"res = nil\neach_with_index(selector) do |e, row_index, col_index|\n  if block.call(e)\n    res = {row_index, col_index}\n    next\n  end\nend\nres\n"}},{"id":"inverse-instance-method","html_id":"inverse-instance-method","name":"inverse","doc":"Returns the inverse of the matrix.\n\nNOTE: Always returns a `Float64` regardless of `T`s type. To coerce\nback into an `Int`, use `#coerce`.\n\n```\nMatrix[[-1, -1], [0, -1]].inverse\n# => [ -1.0,  1.0,\n#       0.0, -1.0 ]\n```","summary":"<p>Returns the inverse of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1013","def":{"name":"inverse","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if square?\nelse\n  raise(ErrDimensionMismatch.new)\nend\nlast = row_count - 1\na = self.coerce(Float64)\nm = Matrix(Float64).identity(row_count)\n0.upto(last) do |k|\n  i = k\n  akk = a[k, k].abs\n  (k + 1).upto(last) do |j|\n    v = a[j, k].abs\n    if v > akk\n      i = j\n      akk = v\n    end\n  end\n  if akk == 0\n    raise(ErrNotRegular.new)\n  end\n  if i != k\n    a.swap_rows(i, k)\n    m.swap_rows(i, k)\n  end\n  akk = a[k, k]\n  0.upto(last) do |ii|\n    if ii == k\n      next\n    end\n    q = a[ii, k] / akk\n    a[ii, k] = 0.0\n    (k + 1).upto(last) do |j|\n      __temp_24 = ii\n      __temp_25 = j\n      a[__temp_24, __temp_25] = a[__temp_24, __temp_25] - (a[k, j] * q)\n    end\n    0.upto(last) do |j|\n      __temp_27 = ii\n      __temp_28 = j\n      m[__temp_27, __temp_28] = m[__temp_27, __temp_28] - (m[k, j] * q)\n    end\n  end\n  (k + 1).upto(last) do |j|\n    a[k, j] = a[k, j] / akk\n  end\n  0.upto(last) do |j|\n    m[k, j] = m[k, j] / akk\n  end\nend\nm\n"}},{"id":"laplace_expansion(*,row=nil,column=nil)-instance-method","html_id":"laplace_expansion(*,row=nil,column=nil)-instance-method","name":"laplace_expansion","doc":"Returns the Laplace expansion along given row or column.\n\n```\nMatrix[[7,6], [3,9]].laplace_expansion(column: 1)\n# => 45\n\nMatrix[[Vector[1, 0], Vector[0, 1]], [2, 3]].laplace_expansion(row: 0)\n# => Vector[3, -2]\n```","summary":"<p>Returns the Laplace expansion along given row or column.</p>","abstract":false,"args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"row","doc":null,"default_value":"nil","external_name":"row","restriction":""},{"name":"column","doc":null,"default_value":"nil","external_name":"column","restriction":""}],"args_string":"(*, row = <span class=\"n\">nil</span>, column = <span class=\"n\">nil</span>)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L642","def":{"name":"laplace_expansion","args":[{"name":"","doc":null,"default_value":"","external_name":"","restriction":""},{"name":"row","doc":null,"default_value":"nil","external_name":"row","restriction":""},{"name":"column","doc":null,"default_value":"nil","external_name":"column","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"num = row || column\nif (!num) || (row && column)\n  raise(ArgumentError.new(\"exactly one the row or column arguments must be specified\"))\nend\nif square?\nelse\n  raise(ErrDimensionMismatch.new)\nend\nif empty?\n  raise(\"laplace_expansion of empty matrix is not defined\")\nend\nif 0 <= num && num < row_count\nelse\n  raise(ArgumentError, \"invalid num (#{num.inspect} for 0..#{row_count - 1})\")\nend\nif row\n  (row(num)).map_with_index do |e, k|\n    e * (cofactor(num, k))\n  end.reduce(&.+)\nelse\n  (col(num)).map_with_index do |e, k|\n    e * (cofactor(k, num))\n  end.reduce(&.+)\nend\n"}},{"id":"lower_triangular?-instance-method","html_id":"lower_triangular?-instance-method","name":"lower_triangular?","doc":"Returns true if this matrix is a lower triangular matrix.","summary":"<p>Returns true if this matrix is a lower triangular matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L720","def":{"name":"lower_triangular?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"els = [] of T\neach(:strict_upper) do |e|\n  els << e\nend\nels.all?(&.zero?)\n"}},{"id":"lup-instance-method","html_id":"lup-instance-method","name":"lup","doc":"Returns the LUP decomposition of the matrix\nSee +LUPDecomposition+.\n\nNOTE: Not working yet\n\n```\na = Matrix[[1, 2], [3, 4]]\nl, u, p = a.lup\nl.lower_triangular? # => true\nu.upper_triangular? # => true\np.permutation?      # => true\nl * u == p * a      # => true\na.lup.solve([2, 5]) # => Vector[(1/1), (1/2)]\n```","summary":"<p>Returns the LUP decomposition of the matrix See +LUPDecomposition+.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1295","def":{"name":"lup","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"LUPDecomposition.new(self)"}},{"id":"map(&block:T->T)-instance-method","html_id":"map(&amp;block:T-&gt;T)-instance-method","name":"map","doc":"Returns a Matrix that is the result of iteration of the given block\nover all elements in the matrix.","summary":"<p>Returns a Matrix that is the result of iteration of the given block over all elements in the matrix.</p>","abstract":false,"args":[],"args_string":"(&block : T -> T)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L359","def":{"name":"map","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T -> T)"},"return_type":"","visibility":"Public","body":"rows = @rows.map do |row|\n  row.map(&block)\nend\nMatrix.new(rows, column_count)\n"}},{"id":"minor(from_row:Int,nrows:Int,from_col:Int,ncols:Int)-instance-method","html_id":"minor(from_row:Int,nrows:Int,from_col:Int,ncols:Int)-instance-method","name":"minor","doc":"Returns a section of the Matrix.\n\n```\nMatrix.diagonal(9, 5, -3).minor(0, 2, 0, 3)\n# => [ 9, 0, 0,\n#      0, 5, 0 ]\n```","summary":"<p>Returns a section of the Matrix.</p>","abstract":false,"args":[{"name":"from_row","doc":null,"default_value":"","external_name":"from_row","restriction":"Int"},{"name":"nrows","doc":null,"default_value":"","external_name":"nrows","restriction":"Int"},{"name":"from_col","doc":null,"default_value":"","external_name":"from_col","restriction":"Int"},{"name":"ncols","doc":null,"default_value":"","external_name":"ncols","restriction":"Int"}],"args_string":"(from_row : Int, nrows : Int, from_col : Int, ncols : Int)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L563","def":{"name":"minor","args":[{"name":"from_row","doc":null,"default_value":"","external_name":"from_row","restriction":"Int"},{"name":"nrows","doc":null,"default_value":"","external_name":"nrows","restriction":"Int"},{"name":"from_col","doc":null,"default_value":"","external_name":"from_col","restriction":"Int"},{"name":"ncols","doc":null,"default_value":"","external_name":"ncols","restriction":"Int"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if nrows < 0 || ncols < 0\n  return nil\nend\nif from_row < 0\n  from_row = from_row + row_count\nend\nif from_col < 0\n  from_col = from_col + column_count\nend\nif ((from_row > row_count || from_col > column_count) || from_row < 0) || from_col < 0\n  return nil\nend\nrows = @rows[from_row, nrows].map do |row|\n  row[from_col, ncols]\nend\nMatrix.new(rows, [column_count - from_col, ncols].min)\n"}},{"id":"minor(row_range:Range,col_range:Range)-instance-method","html_id":"minor(row_range:Range,col_range:Range)-instance-method","name":"minor","doc":"Returns a section of the Matrix.\n\n```\nMatrix.diagonal(9, 5, -3).minor(0..1, 0..2)\n# => [ 9, 0, 0,\n#      0, 5, 0 ]\n```","summary":"<p>Returns a section of the Matrix.</p>","abstract":false,"args":[{"name":"row_range","doc":null,"default_value":"","external_name":"row_range","restriction":"Range"},{"name":"col_range","doc":null,"default_value":"","external_name":"col_range","restriction":"Range"}],"args_string":"(row_range : Range, col_range : Range)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L532","def":{"name":"minor","args":[{"name":"row_range","doc":null,"default_value":"","external_name":"row_range","restriction":"Range"},{"name":"col_range","doc":null,"default_value":"","external_name":"col_range","restriction":"Range"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"from_row = row_range.first\nif from_row < 0\n  from_row = from_row + row_count\nend\nto_row = row_range.end\nif to_row < 0\n  to_row = to_row + row_count\nend\nif row_range.excludes_end?\nelse\n  to_row = to_row + 1\nend\nsize_row = to_row - from_row\nfrom_col = col_range.first\nif from_col < 0\n  from_col = from_col + column_count\nend\nto_col = col_range.end\nif to_col < 0\n  to_col = to_col + column_count\nend\nif col_range.excludes_end?\nelse\n  to_col = to_col + 1\nend\nsize_col = to_col - from_col\nif ((from_row > row_count || from_col > column_count) || from_row < 0) || from_col < 0\n  return nil\nend\nrows = @rows[from_row, size_row].map do |row|\n  row[from_col, size_col]\nend\nMatrix.new(rows, [column_count - from_col, size_col].min)\n"}},{"id":"normal?-instance-method","html_id":"normal?-instance-method","name":"normal?","doc":"Returns `true` if this is a normal matrix.\n\n```\nMatrix[[1, 1, 0], [0, 1, 1], [1, 0, 1]].normal?\n# => true\n```","summary":"<p>Returns <code>true</code> if this is a normal matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L732","def":{"name":"normal?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if square?\nelse\n  return false\nend\nrows.each_with_index do |row_i, i|\n  rows.each_with_index do |row_j, j|\n    s = 0\n    rows.each_with_index do |row_k, k|\n      s = s + ((row_i[k] * row_j[k]) - (row_k[i] * row_k[j]))\n    end\n    if s == 0\n    else\n      return false\n    end\n  end\nend\ntrue\n"}},{"id":"orthogonal?-instance-method","html_id":"orthogonal?-instance-method","name":"orthogonal?","doc":"Returns `true` if this is an orthogonal matrix\n\n```\nMatrix[[1, 0], [0, 1]].orthogonal?\n# => true\n```","summary":"<p>Returns <code>true</code> if this is an orthogonal matrix</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L752","def":{"name":"orthogonal?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if square?\nelse\n  return false\nend\nrows.each_with_index do |row, i|\n  column_count.times do |j|\n    s = 0\n    row_count.times do |k|\n      s = s + (row[k] * rows[k][j])\n    end\n    if s == (i == j ? 1 : 0)\n    else\n      return false\n    end\n  end\nend\ntrue\n"}},{"id":"permutation?-instance-method","html_id":"permutation?-instance-method","name":"permutation?","doc":"Returns `true` if this is a permutation matrix\n\n```\nMatrix[[1, 0], [0, 1]].permutation?\n# => true\n```","summary":"<p>Returns <code>true</code> if this is a permutation matrix</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L772","def":{"name":"permutation?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if square?\nelse\n  return false\nend\ncols = Array.new(column_count, false)\nrows.each_with_index do |row, i|\n  found = false\n  row.each_with_index do |e, j|\n    if e == 1\n      if found || cols[j]\n        return false\n      end\n      found = cols[j] = true\n    else\n      if e != 0\n        return false\n      end\n    end\n  end\n  if found\n  else\n    return false\n  end\nend\ntrue\n"}},{"id":"pretty_print(pp):Nil-instance-method","html_id":"pretty_print(pp):Nil-instance-method","name":"pretty_print","doc":null,"summary":null,"abstract":false,"args":[{"name":"pp","doc":null,"default_value":"","external_name":"pp","restriction":""}],"args_string":"(pp) : Nil","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1414","def":{"name":"pretty_print","args":[{"name":"pp","doc":null,"default_value":"","external_name":"pp","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Nil","visibility":"Public","body":"pp.group(1, \"[\", \"]\") do\n  self.rows.each_with_index do |elem, i|\n    if i > 0\n      pp.comma\n    end\n    elem.pretty_print(pp)\n  end\nend"}},{"id":"rank-instance-method","html_id":"rank-instance-method","name":"rank","doc":"Returns the rank of the matrix.\n\nBeware that using Float values can yield erroneous results\nbecause of their lack of precision.\nConsider using exact types like Rational or BigDecimal instead.\n\n```\nMatrix[[7,6], [3,9]].rank\n# => 2\n```","summary":"<p>Returns the rank of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1175","def":{"name":"rank","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"a = to_a\nlast_column = column_count - 1\nlast_row = row_count - 1\npivot_row = 0\nprevious_pivot = 1\n0.upto(last_column) do |k|\n  switch_row = (pivot_row..last_row).find do |row|\n    a[row][k] != 0\n  end\n  if switch_row\n    if pivot_row == switch_row\n    else\n      a[switch_row], a[pivot_row] = a[pivot_row], a[switch_row]\n    end\n    pivot = a[pivot_row][k]\n    (pivot_row + 1).upto(last_row) do |i|\n      ai = a[i]\n      (k + 1).upto(last_column) do |j|\n        ai[j] = ((pivot * ai[j]) - (ai[k] * a[pivot_row][j])) / previous_pivot\n      end\n    end\n    pivot_row = pivot_row + 1\n    previous_pivot = pivot\n  end\nend\npivot_row\n"}},{"id":"real-instance-method","html_id":"real-instance-method","name":"real","doc":"Returns the real part of the matrix.\n\n```\nMatrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n# => [ 1+2i,  i,  0,\n#         1,  2,  3 ]\nMatrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].real\n# => [ 1,  0,  0,\n#      1,  2,  3 ]\n```","summary":"<p>Returns the real part of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1343","def":{"name":"real","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if real?\nelse\n  raise(ArgumentError.new(\"Matrix#real only works with real matrices (i.e. Matrix(Complex))\"))\nend\nmap(&.real)\n"}},{"id":"real?-instance-method","html_id":"real?-instance-method","name":"real?","doc":"Returns `true` if this matrix contains real numbers,\ni.e. not `Complex`.\n\n```\nrequire \"complex\"\nMatrix[[Complex.new(1, 0)], [Complex.new(0, 1)]].real?\n# => false\n```","summary":"<p>Returns <code>true</code> if this matrix contains real numbers, i.e.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L798","def":{"name":"real?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"!(T.to_s == \"Complex\")"}},{"id":"rect-instance-method","html_id":"rect-instance-method","name":"rect","doc":"Returns an array containing matrices corresponding to the real and imaginary\nparts of the matrix\n\n```\nm.rect == [m.real, m.imag]\n# ==> true for all matrices m\n```","summary":"<p>Returns an array containing matrices corresponding to the real and imaginary parts of the matrix</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1355","def":{"name":"rect","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if real?\nelse\n  raise(ArgumentError.new(\"Matrix#real only works with real matrices (i.e. Matrix(Complex))\"))\nend\n[real, imag]\n"}},{"id":"regular?-instance-method","html_id":"regular?-instance-method","name":"regular?","doc":"Returns `true` if this is a regular (i.e. non-singular) matrix.","summary":"<p>Returns <code>true</code> if this is a regular (i.e.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L803","def":{"name":"regular?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"!singular?"}},{"id":"round(n=0)-instance-method","html_id":"round(n=0)-instance-method","name":"round","doc":"Returns a matrix with entries rounded to the given precision\n(see `Float#round`)","summary":"<p>Returns a matrix with entries rounded to the given precision (see <code>Float#round</code>)</p>","abstract":false,"args":[{"name":"n","doc":null,"default_value":"0","external_name":"n","restriction":""}],"args_string":"(n = <span class=\"n\">0</span>)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1205","def":{"name":"round","args":[{"name":"n","doc":null,"default_value":"0","external_name":"n","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"map do |e|\n  e.round(n)\nend"}},{"id":"row(i,&block:Vector->)-instance-method","html_id":"row(i,&amp;block:Vector-&gt;)-instance-method","name":"row","doc":"Returns a block which yields every Vector in the row (starting at 0).","summary":"<p>Returns a block which yields every Vector in the row (starting at 0).</p>","abstract":false,"args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"args_string":"(i, &block : Vector -> )","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L322","def":{"name":"row","args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(Vector -> )"},"return_type":"","visibility":"Public","body":"(row(i)).each(&block)"}},{"id":"row(i)-instance-method","html_id":"row(i)-instance-method","name":"row","doc":"Returns row vector number `i` of the Matrix as a Vector (starting\nat 0 like a good boy). Raises if the row doesn't exist.","summary":"<p>Returns row vector number <code>i</code> of the Matrix as a Vector (starting at 0 like a good boy).</p>","abstract":false,"args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"args_string":"(i)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L316","def":{"name":"row","args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if i >= row_count || i < (-row_count)\n  raise(IndexError.new)\nend\nVector.elements(self[i])\n"}},{"id":"row?(i)-instance-method","html_id":"row?(i)-instance-method","name":"row?","doc":"Returns row vector number `i` of the Matrix as a Vector (starting\nat 0 like a good boy). Returns nil if the row doesn't exist.","summary":"<p>Returns row vector number <code>i</code> of the Matrix as a Vector (starting at 0 like a good boy).</p>","abstract":false,"args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"args_string":"(i)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L328","def":{"name":"row?","args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"begin\n  row(i)\nrescue IndexError\n  nil\nend"}},{"id":"row_count-instance-method","html_id":"row_count-instance-method","name":"row_count","doc":"Returns the number of rows.","summary":"<p>Returns the number of rows.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L307","def":{"name":"row_count","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@rows.size"}},{"id":"row_vectors-instance-method","html_id":"row_vectors-instance-method","name":"row_vectors","doc":"Returns an array of the row vectors of the matrix. See `Vector`.","summary":"<p>Returns an array of the row vectors of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1371","def":{"name":"row_vectors","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"Array.new(row_count) do |i|\n  row(i)\nend"}},{"id":"singular?-instance-method","html_id":"singular?-instance-method","name":"singular?","doc":"Returns `true` if this is a singular matrix.","summary":"<p>Returns <code>true</code> if this is a singular matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L808","def":{"name":"singular?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"determinant == 0"}},{"id":"square?-instance-method","html_id":"square?-instance-method","name":"square?","doc":"Returns `true` if this is a square matrix.","summary":"<p>Returns <code>true</code> if this is a square matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L813","def":{"name":"square?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"column_count == row_count"}},{"id":"swap_columns(col1,col2)-instance-method","html_id":"swap_columns(col1,col2)-instance-method","name":"swap_columns","doc":"Swaps `col1` and `col2`","summary":"<p>Swaps <code>col1</code> and <code>col2</code></p>","abstract":false,"args":[{"name":"col1","doc":null,"default_value":"","external_name":"col1","restriction":""},{"name":"col2","doc":null,"default_value":"","external_name":"col2","restriction":""}],"args_string":"(col1, col2)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L680","def":{"name":"swap_columns","args":[{"name":"col1","doc":null,"default_value":"","external_name":"col1","restriction":""},{"name":"col2","doc":null,"default_value":"","external_name":"col2","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if col1 >= column_count || col2 >= column_count\n  raise(IndexError.new)\nend\nif col1 < 0\n  col1 = col1 + column_count\nend\nif col2 < 0\n  col2 = col2 + column_count\nend\nif col1 < 0 || col2 < 0\n  raise(IndexError.new)\nend\nrow_count.times do |i|\n  self[i, col1], self[i, col2] = self[i, col2], self[i, col1]\nend\nself\n"}},{"id":"swap_rows(row1,row2)-instance-method","html_id":"swap_rows(row1,row2)-instance-method","name":"swap_rows","doc":"Swaps `row1` and `row2`","summary":"<p>Swaps <code>row1</code> and <code>row2</code></p>","abstract":false,"args":[{"name":"row1","doc":null,"default_value":"","external_name":"row1","restriction":""},{"name":"row2","doc":null,"default_value":"","external_name":"row2","restriction":""}],"args_string":"(row1, row2)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L668","def":{"name":"swap_rows","args":[{"name":"row1","doc":null,"default_value":"","external_name":"row1","restriction":""},{"name":"row2","doc":null,"default_value":"","external_name":"row2","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if row1 >= row_count || row2 >= row_count\n  raise(IndexError.new)\nend\nif row1 < 0\n  row1 = row1 + row_count\nend\nif row2 < 0\n  row2 = row2 + row_count\nend\nif row1 < 0 || row2 < 0\n  raise(IndexError.new)\nend\ncolumn_count.times do |i|\n  self[row1, i], self[row2, i] = self[row2, i], self[row1, i]\nend\nself\n"}},{"id":"symmetric?-instance-method","html_id":"symmetric?-instance-method","name":"symmetric?","doc":"Returns +true+ if this is a symmetric matrix.\nRaises an error if matrix is not square.\n","summary":"<p>Returns +true+ if this is a symmetric matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L820","def":{"name":"symmetric?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if square?\nelse\n  return false\nend\nresult = true\neach_with_index(:strict_upper) do |e, row, col|\n  if e != rows[col][row]\n    result = false\n  end\nend\nresult\n"}},{"id":"t-instance-method","html_id":"t-instance-method","name":"t","doc":"Returns the transpose of the matrix.\n\n```\nMatrix[[1,2], [3,4], [5,6]]\n# => [ 1, 2,\n#      3, 4,\n#      5, 6 ]\nMatrix[[1,2], [3,4], [5,6]].transpose\n# => [ 1, 3, 5,\n#      2, 4, 6 ]\n```","summary":"<p>Returns the transpose of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1244","def":{"name":"t","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"transpose"}},{"id":"to_a-instance-method","html_id":"to_a-instance-method","name":"to_a","doc":"Returns an array of arrays that describe the rows of the matrix.","summary":"<p>Returns an array of arrays that describe the rows of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1385","def":{"name":"to_a","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@rows.clone"}},{"id":"to_json(json:JSON::Builder)-instance-method","html_id":"to_json(json:JSON::Builder)-instance-method","name":"to_json","doc":"Convert the matrix to a json array","summary":"<p>Convert the matrix to a json array</p>","abstract":false,"args":[{"name":"json","doc":null,"default_value":"","external_name":"json","restriction":"JSON::Builder"}],"args_string":"(json : JSON::Builder)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1390","def":{"name":"to_json","args":[{"name":"json","doc":null,"default_value":"","external_name":"json","restriction":"JSON::Builder"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"json.array do\n  each(&.to_json(json))\nend"}},{"id":"to_s(io)-instance-method","html_id":"to_s(io)-instance-method","name":"to_s","doc":null,"summary":null,"abstract":false,"args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""}],"args_string":"(io)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1400","def":{"name":"to_s","args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if empty?\n  \"Matrix.empty(#{row_count}, #{column_count})\"\nelse\n  io << \"Matrix[\"\n  io << (rows.map do |row|\n    (\"[\" + (row.map do |e|\n      e.to_s\n    end.join(\", \"))) + \"]\"\n  end.join(\", \"))\n  io << \"]\"\nend"}},{"id":"tr-instance-method","html_id":"tr-instance-method","name":"tr","doc":"Returns the trace (sum of diagonal elements) of the matrix.\n\n```\nMatrix[[7,6], [3,9]].trace\n# => 16\n```","summary":"<p>Returns the trace (sum of diagonal elements) of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1223","def":{"name":"tr","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"trace"}},{"id":"trace-instance-method","html_id":"trace-instance-method","name":"trace","doc":"Returns the trace (sum of diagonal elements) of the matrix.\n\n```\nMatrix[[7,6], [3,9]].trace\n# => 16\n```","summary":"<p>Returns the trace (sum of diagonal elements) of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1215","def":{"name":"trace","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if square?\nelse\n  raise(ErrDimensionMismatch.new)\nend\n(0...column_count).reduce(0) do |tr, i|\n  tr + @rows[i][i]\nend\n"}},{"id":"transpose-instance-method","html_id":"transpose-instance-method","name":"transpose","doc":"Returns the transpose of the matrix.\n\n```\nMatrix[[1,2], [3,4], [5,6]]\n# => [ 1, 2,\n#      3, 4,\n#      5, 6 ]\nMatrix[[1,2], [3,4], [5,6]].transpose\n# => [ 1, 3, 5,\n#      2, 4, 6 ]\n```","summary":"<p>Returns the transpose of the matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1238","def":{"name":"transpose","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if row_count.zero?\n  return self.class.empty(column_count, 0)\nend\nMatrix.new(@rows.transpose, row_count)\n"}},{"id":"unitary?-instance-method","html_id":"unitary?-instance-method","name":"unitary?","doc":"Returns `true` if this is a unitary matrix","summary":"<p>Returns <code>true</code> if this is a unitary matrix</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L832","def":{"name":"unitary?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if square?\nelse\n  return false\nend\nresult = true\nrows.each_with_index do |row, i|\n  column_count.times do |j|\n    s = 0\n    row_count.times do |k|\n      s = s + (row[k] * rows[k][j])\n    end\n    if s == (i == j ? 1 : 0)\n    else\n      result = false\n    end\n  end\nend\nresult\n"}},{"id":"unsafe_fetch(i)-instance-method","html_id":"unsafe_fetch(i)-instance-method","name":"unsafe_fetch","doc":null,"summary":null,"abstract":false,"args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"args_string":"(i)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1423","def":{"name":"unsafe_fetch","args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@rows.unsafe_fetch(i)"}},{"id":"upper_triangular?-instance-method","html_id":"upper_triangular?-instance-method","name":"upper_triangular?","doc":"Returns true if this matrix is a upper triangular matrix.","summary":"<p>Returns true if this matrix is a upper triangular matrix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L852","def":{"name":"upper_triangular?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"els = [] of T\neach(:strict_lower) do |e|\n  els << e\nend\nels.all?(&.zero?)\n"}},{"id":"vstack(*matrices)-instance-method","html_id":"vstack(*matrices)-instance-method","name":"vstack","doc":"Returns a new matrix resulting by stacking vertically\nthe receiver with the given matrices\n\n```\nx = Matrix[[1, 2], [3, 4]]\ny = Matrix[[5, 6], [7, 8]]\nx.vstack(y)\n# => Matrix[[1, 2], [3, 4], [5, 6], [7, 8]]\n```","summary":"<p>Returns a new matrix resulting by stacking vertically the receiver with the given matrices</p>","abstract":false,"args":[{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"args_string":"(*matrices)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L1257","def":{"name":"vstack","args":[{"name":"matrices","doc":null,"default_value":"","external_name":"matrices","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.vstack(self, *matrices)"}},{"id":"zero?-instance-method","html_id":"zero?-instance-method","name":"zero?","doc":"Returns `true` if this is a matrix with only zero elements","summary":"<p>Returns <code>true</code> if this is a matrix with only zero elements</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix.cr#L859","def":{"name":"zero?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@rows.flatten.all?(&.zero?)"}}],"macros":[],"types":[{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Matrix/EigenvalueDecomposition","path":"Apatite/LinearAlgebra/Matrix/EigenvalueDecomposition.html","kind":"class","full_name":"Apatite::LinearAlgebra::Matrix::EigenvalueDecomposition","name":"EigenvalueDecomposition","abstract":false,"superclass":{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/apatite/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"apatite/linear_algebra/matrix/eigenvalue_decomposition.cr","line_number":12,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix/eigenvalue_decomposition.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Matrix","kind":"class","full_name":"Apatite::LinearAlgebra::Matrix(T)","name":"Matrix"},"doc":"Eigenvalues and eigenvectors of a real matrix.\n\nComputes the eigenvalues and eigenvectors of a matrix A.\n\nIf A is diagonalizable, this provides matrices V and D\nsuch that A = V*D*V.inv, where D is the diagonal matrix with entries\nequal to the eigenvalues and V is formed by the eigenvectors.\n\nIf A is symmetric, then V is orthogonal and thus A = V*D*V.t","summary":"<p>Eigenvalues and eigenvectors of a real matrix.</p>","class_methods":[],"constructors":[{"id":"new(matrix)-class-method","html_id":"new(matrix)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"matrix","doc":null,"default_value":"","external_name":"matrix","restriction":""}],"args_string":"(matrix)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix/eigenvalue_decomposition.cr#L13","def":{"name":"new","args":[{"name":"matrix","doc":null,"default_value":"","external_name":"matrix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(matrix)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]},{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Matrix/LupDecomposition","path":"Apatite/LinearAlgebra/Matrix/LupDecomposition.html","kind":"class","full_name":"Apatite::LinearAlgebra::Matrix::LupDecomposition","name":"LupDecomposition","abstract":false,"superclass":{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/apatite/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"apatite/linear_algebra/matrix/lup_decomposition.cr","line_number":12,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix/lup_decomposition.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Matrix","kind":"class","full_name":"Apatite::LinearAlgebra::Matrix(T)","name":"Matrix"},"doc":"For an m-by-n matrix A with m >= n, the LU decomposition is an m-by-n\nunit lower triangular matrix L, an n-by-n upper triangular matrix U,\nand a m-by-m permutation matrix P so that L*U = P*A.\nIf m < n, then L is m-by-m and U is m-by-n.\n\nThe LUP decomposition with pivoting always exists, even if the matrix is\nsingular, so the constructor will never fail.  The primary use of the\nLU decomposition is in the solution of square systems of simultaneous\nlinear equations.  This will fail if singular? returns true.","summary":"<p>For an m-by-n matrix A with m >= n, the LU decomposition is an m-by-n unit lower triangular matrix L, an n-by-n upper triangular matrix U, and a m-by-m permutation matrix P so that L<em>U = P</em>A.</p>","class_methods":[],"constructors":[{"id":"new(matrix)-class-method","html_id":"new(matrix)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"matrix","doc":null,"default_value":"","external_name":"matrix","restriction":""}],"args_string":"(matrix)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/matrix/lup_decomposition.cr#L13","def":{"name":"new","args":[{"name":"matrix","doc":null,"default_value":"","external_name":"matrix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(matrix)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]}]},{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/NDArray","path":"Apatite/LinearAlgebra/NDArray.html","kind":"class","full_name":"Apatite::LinearAlgebra::NDArray","name":"NDArray","abstract":false,"superclass":{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/apatite/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/apatite/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"},{"html_id":"github.com/watzon/apatite/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/apatite/Iterable","kind":"module","full_name":"Iterable","name":"Iterable"},{"html_id":"github.com/watzon/apatite/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/apatite/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"apatite/linear_algebra/ndarray.cr","line_number":2,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/watzon/apatite/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/apatite/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/apatite/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(data:Array(Number),shape:Array(Int32)?=nil)-class-method","html_id":"new(data:Array(Number),shape:Array(Int32)?=nil)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"data","doc":null,"default_value":"","external_name":"data","restriction":"Array(Number)"},{"name":"shape","doc":null,"default_value":"nil","external_name":"shape","restriction":"Array(Int32) | ::Nil"}],"args_string":"(data : Array(Number), shape : Array(Int32)? = <span class=\"n\">nil</span>)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L18","def":{"name":"new","args":[{"name":"data","doc":null,"default_value":"","external_name":"data","restriction":"Array(Number)"},{"name":"shape","doc":null,"default_value":"nil","external_name":"shape","restriction":"Array(Int32) | ::Nil"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(data, shape)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"[](*args,**options)-instance-method","html_id":"[](*args,**options)-instance-method","name":"[]","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L11","def":{"name":"[]","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@data[*args, **options]"}},{"id":"[](*args,**options,&block)-instance-method","html_id":"[](*args,**options,&amp;block)-instance-method","name":"[]","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options, &block)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L11","def":{"name":"[]","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"@data[*args, **options] do |*yield_args|\n  yield *yield_args\nend"}},{"id":"[]=(*args,**options)-instance-method","html_id":"[]=(*args,**options)-instance-method","name":"[]=","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L13","def":{"name":"[]=","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@data[*args] = **options"}},{"id":"[]?(*args,**options)-instance-method","html_id":"[]?(*args,**options)-instance-method","name":"[]?","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L12","def":{"name":"[]?","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@data[*args, **options]?"}},{"id":"[]?(*args,**options,&block)-instance-method","html_id":"[]?(*args,**options,&amp;block)-instance-method","name":"[]?","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options, &block)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L12","def":{"name":"[]?","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"@data[*args, **options]? do |*yield_args|\n  yield *yield_args\nend"}},{"id":"abs-instance-method","html_id":"abs-instance-method","name":"abs","doc":"Returns the absolute value of every item in the array","summary":"<p>Returns the absolute value of every item in the array</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L24","def":{"name":"abs","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"map do |e|\n  e.abs\nend"}},{"id":"acos-instance-method","html_id":"acos-instance-method","name":"acos","doc":"Returns the arccosine of each element in the current array.","summary":"<p>Returns the arccosine of each element in the current array.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L29","def":{"name":"acos","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":""}},{"id":"data:Array(Float64)-instance-method","html_id":"data:Array(Float64)-instance-method","name":"data","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Array(Float64)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L9","def":{"name":"data","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Float64)","visibility":"Public","body":"@data"}},{"id":"shape:Array(Int32)-instance-method","html_id":"shape:Array(Int32)-instance-method","name":"shape","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Array(Int32)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L11","def":{"name":"shape","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Int32)","visibility":"Public","body":"@shape"}},{"id":"size(*args,**options)-instance-method","html_id":"size(*args,**options)-instance-method","name":"size","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L16","def":{"name":"size","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@data.size(*args, **options)"}},{"id":"size(*args,**options,&block)-instance-method","html_id":"size(*args,**options,&amp;block)-instance-method","name":"size","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options, &block)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L16","def":{"name":"size","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"@data.size(*args, **options) do |*yield_args|\n  yield *yield_args\nend"}},{"id":"to_unsafe(*args,**options)-instance-method","html_id":"to_unsafe(*args,**options)-instance-method","name":"to_unsafe","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L15","def":{"name":"to_unsafe","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@data.to_unsafe(*args, **options)"}},{"id":"to_unsafe(*args,**options,&block)-instance-method","html_id":"to_unsafe(*args,**options,&amp;block)-instance-method","name":"to_unsafe","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options, &block)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L15","def":{"name":"to_unsafe","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"@data.to_unsafe(*args, **options) do |*yield_args|\n  yield *yield_args\nend"}},{"id":"unsafe_fetch(*args,**options)-instance-method","html_id":"unsafe_fetch(*args,**options)-instance-method","name":"unsafe_fetch","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L14","def":{"name":"unsafe_fetch","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@data.unsafe_fetch(*args, **options)"}},{"id":"unsafe_fetch(*args,**options,&block)-instance-method","html_id":"unsafe_fetch(*args,**options,&amp;block)-instance-method","name":"unsafe_fetch","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options, &block)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/ndarray.cr#L14","def":{"name":"unsafe_fetch","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"@data.unsafe_fetch(*args, **options) do |*yield_args|\n  yield *yield_args\nend"}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Vector","path":"Apatite/LinearAlgebra/Vector.html","kind":"class","full_name":"Apatite::LinearAlgebra::Vector(T)","name":"Vector","abstract":false,"superclass":{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/apatite/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/apatite/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/apatite/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"},{"html_id":"github.com/watzon/apatite/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/apatite/Iterable","kind":"module","full_name":"Iterable","name":"Iterable"},{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/apatite/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"apatite/linear_algebra/vector.cr","line_number":7,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/watzon/apatite/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/apatite/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/apatite/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra"},"doc":"Represents a mathematical vector, and also constitutes a row or column\nof a `Matrix`","summary":"<p>Represents a mathematical vector, and also constitutes a row or column of a <code><a href=\"../../Apatite/LinearAlgebra/Matrix.html\">Matrix</a></code></p>","class_methods":[{"id":"[](*array)-class-method","html_id":"[](*array)-class-method","name":"[]","doc":"Creates a new vector from a list of elements.","summary":"<p>Creates a new vector from a list of elements.</p>","abstract":false,"args":[{"name":"array","doc":null,"default_value":"","external_name":"array","restriction":""}],"args_string":"(*array)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L22","def":{"name":"[]","args":[{"name":"array","doc":null,"default_value":"","external_name":"array","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"new(array)"}},{"id":"basis(size,index)-class-method","html_id":"basis(size,index)-class-method","name":"basis","doc":"Returns a standard basis `n`-vector.","summary":"<p>Returns a standard basis <code>n</code>-vector.</p>","abstract":false,"args":[{"name":"size","doc":null,"default_value":"","external_name":"size","restriction":""},{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(size, index)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L34","def":{"name":"basis","args":[{"name":"size","doc":null,"default_value":"","external_name":"size","restriction":""},{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if size < 1\n  raise(ArgumentError.new(\"invalid size (#{size} for 1..)\"))\nend\nif 0 <= index && index < size\nelse\n  raise(ArgumentError.new(\"invalid index (#{index} for 0...#{size})\"))\nend\narray = Array.new(size, 0)\narray[index] = 1\nnew(array)\n"}},{"id":"elements(array,copy=true)-class-method","html_id":"elements(array,copy=true)-class-method","name":"elements","doc":"Creates a vector from an Array. The optional second argument specifies\nwhether the array itself or a copy is used internally.","summary":"<p>Creates a vector from an Array.</p>","abstract":false,"args":[{"name":"array","doc":null,"default_value":"","external_name":"array","restriction":""},{"name":"copy","doc":null,"default_value":"true","external_name":"copy","restriction":""}],"args_string":"(array, copy = <span class=\"n\">true</span>)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L28","def":{"name":"elements","args":[{"name":"array","doc":null,"default_value":"","external_name":"array","restriction":""},{"name":"copy","doc":null,"default_value":"true","external_name":"copy","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if copy\n  array = array.clone\nend\nnew(array)\n"}},{"id":"zero(size)-class-method","html_id":"zero(size)-class-method","name":"zero","doc":"Return a zero vector.","summary":"<p>Return a zero vector.</p>","abstract":false,"args":[{"name":"size","doc":null,"default_value":"","external_name":"size","restriction":""}],"args_string":"(size)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L53","def":{"name":"zero","args":[{"name":"size","doc":null,"default_value":"","external_name":"size","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if size < 0\n  raise(ArgumentError.new(\"invalid size (#{size} for 0..)\"))\nend\narray = Array.new(size, 0)\nnew(array)\n"}}],"constructors":[],"instance_methods":[{"id":"*(x)-instance-method","html_id":"*(x)-instance-method","name":"*","doc":"Multiplies the vector by x, where x is a number or a matrix.","summary":"<p>Multiplies the vector by x, where x is a number or a matrix.</p>","abstract":false,"args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""}],"args_string":"(x)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L60","def":{"name":"*","args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case x\nwhen Number\n  els = @elements.map do |e|\n    (e * x).as(T)\n  end\n  self.class.elements(els, false)\nwhen Vector\n  (self.elements.zip(x.elements)).map do |__arg0|\n    x = __arg0[0]\n    y = __arg0[1]\n    x * y\n  end\nelse\n  raise(ArgumentError.new)\nend"}},{"id":"+(x)-instance-method","html_id":"+(x)-instance-method","name":"+","doc":"Vector addition.","summary":"<p>Vector addition.</p>","abstract":false,"args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""}],"args_string":"(x)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L75","def":{"name":"+","args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case x\nwhen Number\n  els = @elements.map do |e|\n    (e + x).as(T)\n  end\n  self.class.elements(els, false)\nwhen Vector\n  (self.elements.zip(x.elements)).map do |__arg1|\n    x = __arg1[0]\n    y = __arg1[1]\n    x + y\n  end\nelse\n  raise(ArgumentError.new)\nend"}},{"id":"-(x)-instance-method","html_id":"-(x)-instance-method","name":"-","doc":"Vector subtraction.","summary":"<p>Vector subtraction.</p>","abstract":false,"args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""}],"args_string":"(x)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L90","def":{"name":"-","args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case x\nwhen Number\n  els = @elements.map do |e|\n    (e - x).as(T)\n  end\n  self.class.elements(els, false)\nwhen Vector\n  (self.elements.zip(x.elements)).map do |__arg2|\n    x = __arg2[0]\n    y = __arg2[1]\n    x - y\n  end\nelse\n  raise(ArgumentError.new)\nend"}},{"id":"/(x)-instance-method","html_id":"/(x)-instance-method","name":"/","doc":"Vector division.","summary":"<p>Vector division.</p>","abstract":false,"args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""}],"args_string":"(x)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L105","def":{"name":"/","args":[{"name":"x","doc":null,"default_value":"","external_name":"x","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case x\nwhen Number\n  els = @elements.map do |e|\n    (e / x).as(T)\n  end\n  self.class.elements(els, false)\nwhen Vector\n  (self.elements.zip(x.elements)).map do |__arg3|\n    x = __arg3[0]\n    y = __arg3[1]\n    x / y\n  end\nelse\n  raise(ArgumentError.new)\nend"}},{"id":"-instance-method","html_id":"-instance-method","name":"<=>","doc":"Take me to your leader","summary":"<p>Take me to your leader</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L129","def":{"name":"<=>","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if other.is_a?(Vector)\n  @elements <=> other.elements\nelse\n  @elements <=> other\nend"}},{"id":"==(other)-instance-method","html_id":"==(other)-instance-method","name":"==","doc":"Equality operator","summary":"<p>Equality operator</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L120","def":{"name":"==","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if other.is_a?(Vector)\n  @elements == other.elements\nelse\n  @elements == other\nend"}},{"id":"angle_with(v)-instance-method","html_id":"angle_with(v)-instance-method","name":"angle_with","doc":"Returns an angle with another vector. Result is within the [0Math::PI].","summary":"<p>Returns an angle with another vector.</p>","abstract":false,"args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"args_string":"(v)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L138","def":{"name":"angle_with","args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if size != v.size\n  raise(ErrDimensionMismatch.new)\nend\nprod = magnitude * v.magnitude\nif prod == 0\n  raise(ZeroVectorError.new(\"Can't get angle of zero vector\"))\nend\nMath.acos((inner_product(v)) / prod)\n"}},{"id":"clone-instance-method","html_id":"clone-instance-method","name":"clone","doc":"Returns a copy of the vector.","summary":"<p>Returns a copy of the vector.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L147","def":{"name":"clone","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.elements(@elements)"}},{"id":"coerce(klass,*args)-instance-method","html_id":"coerce(klass,*args)-instance-method","name":"coerce","doc":"The coerce method allows you to attempt to coerce the elements\nin the matrix to another type. The type","summary":"<p>The coerce method allows you to attempt to coerce the elements in the matrix to another type.</p>","abstract":false,"args":[{"name":"klass","doc":null,"default_value":"","external_name":"klass","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(klass, *args)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L249","def":{"name":"coerce","args":[{"name":"klass","doc":null,"default_value":"","external_name":"klass","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":1,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case klass.to_s\nwhen \"Complex\"\n  if args[0]?\n  else\n    raise(\"coercing to a Complex requires a second argument\")\n  end\n  els = @elements.map do |e|\n    Complex.new(e, args[0].as(Int32))\n  end\nwhen \"BigInt\"\n  base = args[0]? || 10\n  els = @elements.map do |e|\n    klass.new(e, base)\n  end\nwhen \"BigRational\"\n  if args[0]?\n  else\n    raise(\"coercing to a BigRational requires a second argument to use as a denominator\")\n  end\n  els = @elements.map do |e|\n    klass.new(e, args[0])\n  end\nelse\n  els = @elements.map do |e|\n    klass.new(e)\n  end\nend\nVector.elements(els)\n"}},{"id":"cross(v)-instance-method","html_id":"cross(v)-instance-method","name":"cross","doc":"Returns the cross product of this vector with the others.","summary":"<p>Returns the cross product of this vector with the others.</p>","abstract":false,"args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"args_string":"(v)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L193","def":{"name":"cross","args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"cross_product(v)"}},{"id":"cross_product(*vs)-instance-method","html_id":"cross_product(*vs)-instance-method","name":"cross_product","doc":"Returns the cross product of this vector with the others.","summary":"<p>Returns the cross product of this vector with the others.</p>","abstract":false,"args":[{"name":"vs","doc":null,"default_value":"","external_name":"vs","restriction":""}],"args_string":"(*vs)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L170","def":{"name":"cross_product","args":[{"name":"vs","doc":null,"default_value":"","external_name":"vs","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if size >= 2\nelse\n  raise(ErrOperationNotDefined.new(\"cross product is not defined on vectors of dimension #{size}\"))\nend\nif vs.size == (size - 2)\nelse\n  raise(ArgumentError.new(\"wrong number of arguments (#{vs.size} for #{size - 2})\"))\nend\nvs.each do |v|\n  if v.size == size\n  else\n    raise(ErrDimensionMismatch.new)\n  end\nend\ncase size\nwhen 2\n  Vector[-@elements[1], @elements[0]]\nwhen 3\n  v = vs[0]\n  Vector[(v[2] * @elements[1]) - (v[1] * @elements[2]), (v[0] * @elements[2]) - (v[2] * @elements[0]), (v[1] * @elements[0]) - (v[0] * @elements[1])]\nelse\n  rows = (self + vs) + (Array.new(size) do |i|\n    Vector.basis(size, i)\n  end)\n  (Matrix.rows(rows)).laplace_expansion(row: size - 1)\nend\n"}},{"id":"dot(v)-instance-method","html_id":"dot(v)-instance-method","name":"dot","doc":"Returns the inner product of this vector with the other.","summary":"<p>Returns the inner product of this vector with the other.</p>","abstract":false,"args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"args_string":"(v)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L207","def":{"name":"dot","args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"inner_product(v)"}},{"id":"each(*args,**options)-instance-method","html_id":"each(*args,**options)-instance-method","name":"each","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L14","def":{"name":"each","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@elements.each(*args, **options)"}},{"id":"each(*args,**options,&block)-instance-method","html_id":"each(*args,**options,&amp;block)-instance-method","name":"each","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args, **options, &block)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L14","def":{"name":"each","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":{"name":"options","doc":null,"default_value":"","external_name":"options","restriction":""},"splat_index":0,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"@elements.each(*args, **options) do |*yield_args|\n  yield *yield_args\nend"}},{"id":"each2(v,&block)-instance-method","html_id":"each2(v,&amp;block)-instance-method","name":"each2","doc":"Iterate over the elements of this vector and `v` in conjunction.","summary":"<p>Iterate over the elements of this vector and <code>v</code> in conjunction.</p>","abstract":false,"args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"args_string":"(v, &block)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L212","def":{"name":"each2","args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"double_splat":null,"splat_index":null,"yields":2,"block_arg":null,"return_type":"","visibility":"Public","body":"if size != v.size\n  raise(ErrDimensionMismatch.new)\nend\nsize.times do |i|\n  yield @elements[i], v[i]\nend\nself\n"}},{"id":"inner_product(v)-instance-method","html_id":"inner_product(v)-instance-method","name":"inner_product","doc":"Returns the inner product of this vector with the other.","summary":"<p>Returns the inner product of this vector with the other.</p>","abstract":false,"args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"args_string":"(v)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L198","def":{"name":"inner_product","args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if size != v.size\n  raise(ErrDimensionMismatch.new)\nend\np = 0\neach2(v) do |v1, v2|\n  p = p + (v1 * v2)\nend\np\n"}},{"id":"inspect-instance-method","html_id":"inspect-instance-method","name":"inspect","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L286","def":{"name":"inspect","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"<#Vector(#{T}) [#{@elements.join(\", \")}]>\""}},{"id":"magnitude-instance-method","html_id":"magnitude-instance-method","name":"magnitude","doc":"Returns the modulus (Pythagorean distance) of the vector.","summary":"<p>Returns the modulus (Pythagorean distance) of the vector.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L221","def":{"name":"magnitude","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"Math.sqrt(@elements.reduce(0) do |v, e|\n  v + e.abs2\nend)"}},{"id":"map(&block:T->UNDERSCORE)-instance-method","html_id":"map(&amp;block:T-&gt;UNDERSCORE)-instance-method","name":"map","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"(&block : T -> UNDERSCORE)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L151","def":{"name":"map","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T -> _)"},"return_type":"","visibility":"Public","body":"els = @elements.map(&block)\nself.class.elements(els, false)\n"}},{"id":"map2(v,&block:T,T->UNDERSCORE)-instance-method","html_id":"map2(v,&amp;block:T,T-&gt;UNDERSCORE)-instance-method","name":"map2","doc":null,"summary":null,"abstract":false,"args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"args_string":"(v, &block : T, T -> UNDERSCORE)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L156","def":{"name":"map2","args":[{"name":"v","doc":null,"default_value":"","external_name":"v","restriction":""}],"double_splat":null,"splat_index":null,"yields":2,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T, T -> _)"},"return_type":"","visibility":"Public","body":"if size != v.size\n  raise(ErrDimensionMismatch.new)\nend\narr = Array.new(size) do |i|\n  yield @elements[i], v[i]\nend\nself.class.elements(arr, false)\n"}},{"id":"norm-instance-method","html_id":"norm-instance-method","name":"norm","doc":"Returns the modulus (Pythagorean distance) of the vector.","summary":"<p>Returns the modulus (Pythagorean distance) of the vector.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L226","def":{"name":"norm","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"magnitude"}},{"id":"normalize-instance-method","html_id":"normalize-instance-method","name":"normalize","doc":"Returns a new vector with the same direction but with norm 1","summary":"<p>Returns a new vector with the same direction but with norm 1</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L231","def":{"name":"normalize","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"n = magnitude\nif n == 0\n  raise(ZeroVectorError.new(\"Zero vectors can not be normalized\"))\nend\nself / n\n"}},{"id":"r-instance-method","html_id":"r-instance-method","name":"r","doc":"Returns a new vector with the same direction but with norm 1","summary":"<p>Returns a new vector with the same direction but with norm 1</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L238","def":{"name":"r","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"magnitude"}},{"id":"round(ndigits=0)-instance-method","html_id":"round(ndigits=0)-instance-method","name":"round","doc":"Returns a vector with entries rounded to the given precision.","summary":"<p>Returns a vector with entries rounded to the given precision.</p>","abstract":false,"args":[{"name":"ndigits","doc":null,"default_value":"0","external_name":"ndigits","restriction":""}],"args_string":"(ndigits = <span class=\"n\">0</span>)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L243","def":{"name":"round","args":[{"name":"ndigits","doc":null,"default_value":"0","external_name":"ndigits","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"map do |e|\n  e.round(ndigits)\nend"}},{"id":"to_a-instance-method","html_id":"to_a-instance-method","name":"to_a","doc":"Returns the elements of the vector in an array.","summary":"<p>Returns the elements of the vector in an array.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L268","def":{"name":"to_a","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@elements.dup"}},{"id":"to_matrix-instance-method","html_id":"to_matrix-instance-method","name":"to_matrix","doc":"Return a single-column matrix from this vector.","summary":"<p>Return a single-column matrix from this vector.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L273","def":{"name":"to_matrix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"Matrix.column_vector(self)"}},{"id":"to_s-instance-method","html_id":"to_s-instance-method","name":"to_s","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L277","def":{"name":"to_s","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(\"Vector{\" + (@elements.join(\", \"))) + \"}\""}},{"id":"unsafe_fetch(i)-instance-method","html_id":"unsafe_fetch(i)-instance-method","name":"unsafe_fetch","doc":null,"summary":null,"abstract":false,"args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"args_string":"(i)","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L290","def":{"name":"unsafe_fetch","args":[{"name":"i","doc":null,"default_value":"","external_name":"i","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@elements.unsafe_fetch(i)"}},{"id":"zero?-instance-method","html_id":"zero?-instance-method","name":"zero?","doc":"Returns `true` if all elements are zero.","summary":"<p>Returns <code>true</code> if all elements are zero.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/vector.cr#L282","def":{"name":"zero?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"all?(&:\"zero?\")"}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/ZeroVectorError","path":"Apatite/LinearAlgebra/ZeroVectorError.html","kind":"class","full_name":"Apatite::LinearAlgebra::ZeroVectorError","name":"ZeroVectorError","abstract":false,"superclass":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Error","kind":"class","full_name":"Apatite::LinearAlgebra::Error","name":"Error"},"ancestors":[{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra/Error","kind":"class","full_name":"Apatite::LinearAlgebra::Error","name":"Error"},{"html_id":"github.com/watzon/apatite/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/apatite/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"apatite/linear_algebra/error.cr","line_number":5,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/linear_algebra/error.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/apatite/Apatite/LinearAlgebra","kind":"module","full_name":"Apatite::LinearAlgebra","name":"LinearAlgebra"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]}]}]},{"html_id":"github.com/watzon/apatite/Array","path":"Array.html","kind":"class","full_name":"Array(T)","name":"Array","abstract":false,"superclass":{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/apatite/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/apatite/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"},{"html_id":"github.com/watzon/apatite/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/apatite/Iterable","kind":"module","full_name":"Iterable","name":"Iterable"},{"html_id":"github.com/watzon/apatite/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/apatite/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"apatite/core_ext/array.cr","line_number":1,"url":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/core_ext/array.cr"}],"repository_name":"github.com/watzon/apatite","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/watzon/apatite/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/apatite/Indexable","kind":"module","full_name":"Indexable","name":"Indexable"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"An `Array` is an ordered, integer-indexed collection of objects of type T.\n\nArray indexing starts at 0. A negative index is assumed to be\nrelative to the end of the array: -1 indicates the last element,\n-2 is the next to last element, and so on.\n\nAn `Array` can be created using the usual `new` method (several are provided), or with an array literal:\n\n```\nArray(Int32).new  # => []\n[1, 2, 3]         # Array(Int32)\n[1, \"hello\", 'x'] # Array(Int32 | String | Char)\n```\n\nAn `Array` can have mixed types, meaning T will be a union of types, but these are determined\nwhen the array is created, either by specifying T or by using an array literal. In the latter\ncase, T will be set to the union of the array literal elements' types.\n\nWhen creating an empty array you must always specify T:\n\n```\n[] of Int32 # same as Array(Int32)\n[]          # syntax error\n```\n\nAn `Array` is implemented using an internal buffer of some capacity\nand is reallocated when elements are pushed to it when more capacity\nis needed. This is normally known as a [dynamic array](http://en.wikipedia.org/wiki/Dynamic_array).\n\nYou can use a special array literal syntax with other types too, as long as they define an argless\n`new` method and a `<<` method. `Set` is one such type:\n\n```\nset = Set{1, 2, 3} # => Set{1, 2, 3}\nset.class          # => Set(Int32)\n```\n\nThe above is the same as this:\n\n```\nset = Set(typeof(1, 2, 3)).new\nset << 1\nset << 2\nset << 3\n```","summary":"<p>An <code><a href=\"Array.html\">Array</a></code> is an ordered, integer-indexed collection of objects of type T.</p>","class_methods":[],"constructors":[],"instance_methods":[{"id":"all?-instance-method","html_id":"all?-instance-method","name":"all?","doc":"Tests whether all elements evaluate to true","summary":"<p>Tests whether all elements evaluate to true</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/core_ext/array.cr#L3","def":{"name":"all?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"each do |i|\n  if (!(!i)) == false\n    return false\n  end\nend\ntrue\n"}},{"id":"any?-instance-method","html_id":"any?-instance-method","name":"any?","doc":"Tests whether any of the elements evaluate to true","summary":"<p>Tests whether any of the elements evaluate to true</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/core_ext/array.cr#L11","def":{"name":"any?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"each do |i|\n  if (!(!i)) == true\n    return true\n  end\nend\nfalse\n"}},{"id":"shape-instance-method","html_id":"shape-instance-method","name":"shape","doc":"Get the array's dimensions","summary":"<p>Get the array's dimensions</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/core_ext/array.cr#L19","def":{"name":"shape","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"max = max_by do |i|\n  i.is_a?(Array) ? i.size : i\nend\nmax.is_a?(Array) ? [size, max.size] : [max]\n"}},{"id":"to_vec-instance-method","html_id":"to_vec-instance-method","name":"to_vec","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/apatite/blob/6e67ceb81b0b3c61d48b74e5ca5154866a9abd1a/src/apatite/core_ext/array.cr#L24","def":{"name":"to_vec","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"Apatite::Vector.create(self)"}}],"macros":[],"types":[]}]}})